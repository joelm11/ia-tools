// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.0
//   protoc               v5.29.3
// source: codec_config.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { ObuHeaderMetadata } from "./obu_header";

export const protobufPackage = "iamf_tools_cli_proto";

/**
 * Valid proto enums start at index 1, which are different from the
 * corresponding enums in C++, e.g. kLpcmBigEndian = 0.
 */
export enum LpcmFormatFlags {
  LPCM_INVALID = 0,
  LPCM_BIG_ENDIAN = 1,
  LPCM_LITTLE_ENDIAN = 2,
  UNRECOGNIZED = -1,
}

export function lpcmFormatFlagsFromJSON(object: any): LpcmFormatFlags {
  switch (object) {
    case 0:
    case "LPCM_INVALID":
      return LpcmFormatFlags.LPCM_INVALID;
    case 1:
    case "LPCM_BIG_ENDIAN":
      return LpcmFormatFlags.LPCM_BIG_ENDIAN;
    case 2:
    case "LPCM_LITTLE_ENDIAN":
      return LpcmFormatFlags.LPCM_LITTLE_ENDIAN;
    case -1:
    case "UNRECOGNIZED":
    default:
      return LpcmFormatFlags.UNRECOGNIZED;
  }
}

export function lpcmFormatFlagsToJSON(object: LpcmFormatFlags): string {
  switch (object) {
    case LpcmFormatFlags.LPCM_INVALID:
      return "LPCM_INVALID";
    case LpcmFormatFlags.LPCM_BIG_ENDIAN:
      return "LPCM_BIG_ENDIAN";
    case LpcmFormatFlags.LPCM_LITTLE_ENDIAN:
      return "LPCM_LITTLE_ENDIAN";
    case LpcmFormatFlags.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum OpusApplicationFlag {
  APPLICATION_INVALID = 0,
  APPLICATION_VOIP = 1,
  APPLICATION_AUDIO = 2,
  APPLICATION_RESTRICTED_LOWDELAY = 3,
  UNRECOGNIZED = -1,
}

export function opusApplicationFlagFromJSON(object: any): OpusApplicationFlag {
  switch (object) {
    case 0:
    case "APPLICATION_INVALID":
      return OpusApplicationFlag.APPLICATION_INVALID;
    case 1:
    case "APPLICATION_VOIP":
      return OpusApplicationFlag.APPLICATION_VOIP;
    case 2:
    case "APPLICATION_AUDIO":
      return OpusApplicationFlag.APPLICATION_AUDIO;
    case 3:
    case "APPLICATION_RESTRICTED_LOWDELAY":
      return OpusApplicationFlag.APPLICATION_RESTRICTED_LOWDELAY;
    case -1:
    case "UNRECOGNIZED":
    default:
      return OpusApplicationFlag.UNRECOGNIZED;
  }
}

export function opusApplicationFlagToJSON(object: OpusApplicationFlag): string {
  switch (object) {
    case OpusApplicationFlag.APPLICATION_INVALID:
      return "APPLICATION_INVALID";
    case OpusApplicationFlag.APPLICATION_VOIP:
      return "APPLICATION_VOIP";
    case OpusApplicationFlag.APPLICATION_AUDIO:
      return "APPLICATION_AUDIO";
    case OpusApplicationFlag.APPLICATION_RESTRICTED_LOWDELAY:
      return "APPLICATION_RESTRICTED_LOWDELAY";
    case OpusApplicationFlag.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum SampleFrequencyIndex {
  AAC_SAMPLE_FREQUENCY_INDEX_INVALID = 0,
  AAC_SAMPLE_FREQUENCY_INDEX_96000 = 1,
  AAC_SAMPLE_FREQUENCY_INDEX_88200 = 2,
  AAC_SAMPLE_FREQUENCY_INDEX_64000 = 3,
  AAC_SAMPLE_FREQUENCY_INDEX_48000 = 4,
  AAC_SAMPLE_FREQUENCY_INDEX_44100 = 5,
  AAC_SAMPLE_FREQUENCY_INDEX_32000 = 6,
  AAC_SAMPLE_FREQUENCY_INDEX_24000 = 7,
  AAC_SAMPLE_FREQUENCY_INDEX_22050 = 8,
  AAC_SAMPLE_FREQUENCY_INDEX_16000 = 9,
  AAC_SAMPLE_FREQUENCY_INDEX_12000 = 10,
  AAC_SAMPLE_FREQUENCY_INDEX_11025 = 11,
  AAC_SAMPLE_FREQUENCY_INDEX_8000 = 12,
  AAC_SAMPLE_FREQUENCY_INDEX_7350 = 13,
  AAC_SAMPLE_FREQUENCY_INDEX_RESERVED_A = 14,
  AAC_SAMPLE_FREQUENCY_INDEX_RESERVED_B = 15,
  AAC_SAMPLE_FREQUENCY_INDEX_ESCAPE_VALUE = 16,
  UNRECOGNIZED = -1,
}

export function sampleFrequencyIndexFromJSON(object: any): SampleFrequencyIndex {
  switch (object) {
    case 0:
    case "AAC_SAMPLE_FREQUENCY_INDEX_INVALID":
      return SampleFrequencyIndex.AAC_SAMPLE_FREQUENCY_INDEX_INVALID;
    case 1:
    case "AAC_SAMPLE_FREQUENCY_INDEX_96000":
      return SampleFrequencyIndex.AAC_SAMPLE_FREQUENCY_INDEX_96000;
    case 2:
    case "AAC_SAMPLE_FREQUENCY_INDEX_88200":
      return SampleFrequencyIndex.AAC_SAMPLE_FREQUENCY_INDEX_88200;
    case 3:
    case "AAC_SAMPLE_FREQUENCY_INDEX_64000":
      return SampleFrequencyIndex.AAC_SAMPLE_FREQUENCY_INDEX_64000;
    case 4:
    case "AAC_SAMPLE_FREQUENCY_INDEX_48000":
      return SampleFrequencyIndex.AAC_SAMPLE_FREQUENCY_INDEX_48000;
    case 5:
    case "AAC_SAMPLE_FREQUENCY_INDEX_44100":
      return SampleFrequencyIndex.AAC_SAMPLE_FREQUENCY_INDEX_44100;
    case 6:
    case "AAC_SAMPLE_FREQUENCY_INDEX_32000":
      return SampleFrequencyIndex.AAC_SAMPLE_FREQUENCY_INDEX_32000;
    case 7:
    case "AAC_SAMPLE_FREQUENCY_INDEX_24000":
      return SampleFrequencyIndex.AAC_SAMPLE_FREQUENCY_INDEX_24000;
    case 8:
    case "AAC_SAMPLE_FREQUENCY_INDEX_22050":
      return SampleFrequencyIndex.AAC_SAMPLE_FREQUENCY_INDEX_22050;
    case 9:
    case "AAC_SAMPLE_FREQUENCY_INDEX_16000":
      return SampleFrequencyIndex.AAC_SAMPLE_FREQUENCY_INDEX_16000;
    case 10:
    case "AAC_SAMPLE_FREQUENCY_INDEX_12000":
      return SampleFrequencyIndex.AAC_SAMPLE_FREQUENCY_INDEX_12000;
    case 11:
    case "AAC_SAMPLE_FREQUENCY_INDEX_11025":
      return SampleFrequencyIndex.AAC_SAMPLE_FREQUENCY_INDEX_11025;
    case 12:
    case "AAC_SAMPLE_FREQUENCY_INDEX_8000":
      return SampleFrequencyIndex.AAC_SAMPLE_FREQUENCY_INDEX_8000;
    case 13:
    case "AAC_SAMPLE_FREQUENCY_INDEX_7350":
      return SampleFrequencyIndex.AAC_SAMPLE_FREQUENCY_INDEX_7350;
    case 14:
    case "AAC_SAMPLE_FREQUENCY_INDEX_RESERVED_A":
      return SampleFrequencyIndex.AAC_SAMPLE_FREQUENCY_INDEX_RESERVED_A;
    case 15:
    case "AAC_SAMPLE_FREQUENCY_INDEX_RESERVED_B":
      return SampleFrequencyIndex.AAC_SAMPLE_FREQUENCY_INDEX_RESERVED_B;
    case 16:
    case "AAC_SAMPLE_FREQUENCY_INDEX_ESCAPE_VALUE":
      return SampleFrequencyIndex.AAC_SAMPLE_FREQUENCY_INDEX_ESCAPE_VALUE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SampleFrequencyIndex.UNRECOGNIZED;
  }
}

export function sampleFrequencyIndexToJSON(object: SampleFrequencyIndex): string {
  switch (object) {
    case SampleFrequencyIndex.AAC_SAMPLE_FREQUENCY_INDEX_INVALID:
      return "AAC_SAMPLE_FREQUENCY_INDEX_INVALID";
    case SampleFrequencyIndex.AAC_SAMPLE_FREQUENCY_INDEX_96000:
      return "AAC_SAMPLE_FREQUENCY_INDEX_96000";
    case SampleFrequencyIndex.AAC_SAMPLE_FREQUENCY_INDEX_88200:
      return "AAC_SAMPLE_FREQUENCY_INDEX_88200";
    case SampleFrequencyIndex.AAC_SAMPLE_FREQUENCY_INDEX_64000:
      return "AAC_SAMPLE_FREQUENCY_INDEX_64000";
    case SampleFrequencyIndex.AAC_SAMPLE_FREQUENCY_INDEX_48000:
      return "AAC_SAMPLE_FREQUENCY_INDEX_48000";
    case SampleFrequencyIndex.AAC_SAMPLE_FREQUENCY_INDEX_44100:
      return "AAC_SAMPLE_FREQUENCY_INDEX_44100";
    case SampleFrequencyIndex.AAC_SAMPLE_FREQUENCY_INDEX_32000:
      return "AAC_SAMPLE_FREQUENCY_INDEX_32000";
    case SampleFrequencyIndex.AAC_SAMPLE_FREQUENCY_INDEX_24000:
      return "AAC_SAMPLE_FREQUENCY_INDEX_24000";
    case SampleFrequencyIndex.AAC_SAMPLE_FREQUENCY_INDEX_22050:
      return "AAC_SAMPLE_FREQUENCY_INDEX_22050";
    case SampleFrequencyIndex.AAC_SAMPLE_FREQUENCY_INDEX_16000:
      return "AAC_SAMPLE_FREQUENCY_INDEX_16000";
    case SampleFrequencyIndex.AAC_SAMPLE_FREQUENCY_INDEX_12000:
      return "AAC_SAMPLE_FREQUENCY_INDEX_12000";
    case SampleFrequencyIndex.AAC_SAMPLE_FREQUENCY_INDEX_11025:
      return "AAC_SAMPLE_FREQUENCY_INDEX_11025";
    case SampleFrequencyIndex.AAC_SAMPLE_FREQUENCY_INDEX_8000:
      return "AAC_SAMPLE_FREQUENCY_INDEX_8000";
    case SampleFrequencyIndex.AAC_SAMPLE_FREQUENCY_INDEX_7350:
      return "AAC_SAMPLE_FREQUENCY_INDEX_7350";
    case SampleFrequencyIndex.AAC_SAMPLE_FREQUENCY_INDEX_RESERVED_A:
      return "AAC_SAMPLE_FREQUENCY_INDEX_RESERVED_A";
    case SampleFrequencyIndex.AAC_SAMPLE_FREQUENCY_INDEX_RESERVED_B:
      return "AAC_SAMPLE_FREQUENCY_INDEX_RESERVED_B";
    case SampleFrequencyIndex.AAC_SAMPLE_FREQUENCY_INDEX_ESCAPE_VALUE:
      return "AAC_SAMPLE_FREQUENCY_INDEX_ESCAPE_VALUE";
    case SampleFrequencyIndex.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum FlacBlockType {
  FLAC_BLOCK_TYPE_INVALID = 0,
  FLAC_BLOCK_TYPE_STREAMINFO = 1,
  FLAC_BLOCK_TYPE_PADDING = 2,
  FLAC_BLOCK_TYPE_APPLICATION = 3,
  FLAC_BLOCK_TYPE_SEEKTABLE = 4,
  FLAC_BLOCK_TYPE_VORBIS_COMMENT = 5,
  FLAC_BLOCK_TYPE_CUESHEET = 6,
  FLAC_BLOCK_TYPE_PICTURE = 7,
  UNRECOGNIZED = -1,
}

export function flacBlockTypeFromJSON(object: any): FlacBlockType {
  switch (object) {
    case 0:
    case "FLAC_BLOCK_TYPE_INVALID":
      return FlacBlockType.FLAC_BLOCK_TYPE_INVALID;
    case 1:
    case "FLAC_BLOCK_TYPE_STREAMINFO":
      return FlacBlockType.FLAC_BLOCK_TYPE_STREAMINFO;
    case 2:
    case "FLAC_BLOCK_TYPE_PADDING":
      return FlacBlockType.FLAC_BLOCK_TYPE_PADDING;
    case 3:
    case "FLAC_BLOCK_TYPE_APPLICATION":
      return FlacBlockType.FLAC_BLOCK_TYPE_APPLICATION;
    case 4:
    case "FLAC_BLOCK_TYPE_SEEKTABLE":
      return FlacBlockType.FLAC_BLOCK_TYPE_SEEKTABLE;
    case 5:
    case "FLAC_BLOCK_TYPE_VORBIS_COMMENT":
      return FlacBlockType.FLAC_BLOCK_TYPE_VORBIS_COMMENT;
    case 6:
    case "FLAC_BLOCK_TYPE_CUESHEET":
      return FlacBlockType.FLAC_BLOCK_TYPE_CUESHEET;
    case 7:
    case "FLAC_BLOCK_TYPE_PICTURE":
      return FlacBlockType.FLAC_BLOCK_TYPE_PICTURE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return FlacBlockType.UNRECOGNIZED;
  }
}

export function flacBlockTypeToJSON(object: FlacBlockType): string {
  switch (object) {
    case FlacBlockType.FLAC_BLOCK_TYPE_INVALID:
      return "FLAC_BLOCK_TYPE_INVALID";
    case FlacBlockType.FLAC_BLOCK_TYPE_STREAMINFO:
      return "FLAC_BLOCK_TYPE_STREAMINFO";
    case FlacBlockType.FLAC_BLOCK_TYPE_PADDING:
      return "FLAC_BLOCK_TYPE_PADDING";
    case FlacBlockType.FLAC_BLOCK_TYPE_APPLICATION:
      return "FLAC_BLOCK_TYPE_APPLICATION";
    case FlacBlockType.FLAC_BLOCK_TYPE_SEEKTABLE:
      return "FLAC_BLOCK_TYPE_SEEKTABLE";
    case FlacBlockType.FLAC_BLOCK_TYPE_VORBIS_COMMENT:
      return "FLAC_BLOCK_TYPE_VORBIS_COMMENT";
    case FlacBlockType.FLAC_BLOCK_TYPE_CUESHEET:
      return "FLAC_BLOCK_TYPE_CUESHEET";
    case FlacBlockType.FLAC_BLOCK_TYPE_PICTURE:
      return "FLAC_BLOCK_TYPE_PICTURE";
    case FlacBlockType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum CodecId {
  CODEC_ID_INVALID = 0,
  /** CODEC_ID_OPUS - "Opus" */
  CODEC_ID_OPUS = 1332770163,
  /** CODEC_ID_LPCM - "ipcm" */
  CODEC_ID_LPCM = 1768973165,
  /** CODEC_ID_AAC_LC - "mp4a" */
  CODEC_ID_AAC_LC = 1836069985,
  /** CODEC_ID_FLAC - "fLaC" */
  CODEC_ID_FLAC = 1716281667,
  UNRECOGNIZED = -1,
}

export function codecIdFromJSON(object: any): CodecId {
  switch (object) {
    case 0:
    case "CODEC_ID_INVALID":
      return CodecId.CODEC_ID_INVALID;
    case 1332770163:
    case "CODEC_ID_OPUS":
      return CodecId.CODEC_ID_OPUS;
    case 1768973165:
    case "CODEC_ID_LPCM":
      return CodecId.CODEC_ID_LPCM;
    case 1836069985:
    case "CODEC_ID_AAC_LC":
      return CodecId.CODEC_ID_AAC_LC;
    case 1716281667:
    case "CODEC_ID_FLAC":
      return CodecId.CODEC_ID_FLAC;
    case -1:
    case "UNRECOGNIZED":
    default:
      return CodecId.UNRECOGNIZED;
  }
}

export function codecIdToJSON(object: CodecId): string {
  switch (object) {
    case CodecId.CODEC_ID_INVALID:
      return "CODEC_ID_INVALID";
    case CodecId.CODEC_ID_OPUS:
      return "CODEC_ID_OPUS";
    case CodecId.CODEC_ID_LPCM:
      return "CODEC_ID_LPCM";
    case CodecId.CODEC_ID_AAC_LC:
      return "CODEC_ID_AAC_LC";
    case CodecId.CODEC_ID_FLAC:
      return "CODEC_ID_FLAC";
    case CodecId.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface LpcmDecoderConfig {
  sampleFormatFlags?: LpcmFormatFlags | undefined;
  sampleSize?: number | undefined;
  sampleRate?: number | undefined;
}

/** Settings to configure `libopus`. */
export interface OpusEncoderMetadata {
  application?: OpusApplicationFlag | undefined;
  useFloatApi?:
    | boolean
    | undefined;
  /**
   * Fields to control the bitrate.
   *
   *  - If the substream is present in `substream_id_to_bitrate_override`, the
   *  bitrate override is used.
   *  - Otherwise a bitrate is calculated based on the number of channels.
   *    - One channel: `target_bitrate_per_channel`.
   *    - Two channels: `target_bitrate_per_channel * 2 *
   *  coupling_rate_adjustment`.
   */
  targetBitratePerChannel?: number | undefined;
  couplingRateAdjustment?: number | undefined;
  substreamIdToBitrateOverride: { [key: number]: number };
}

export interface OpusEncoderMetadata_SubstreamIdToBitrateOverrideEntry {
  key: number;
  value: number;
}

export interface OpusDecoderConfig {
  version?: number | undefined;
  outputChannelCount?: number | undefined;
  preSkip?: number | undefined;
  inputSampleRate?: number | undefined;
  outputGain?: number | undefined;
  mappingFamily?: number | undefined;
  opusEncoderMetadata?: OpusEncoderMetadata | undefined;
}

/** Settings to configure `fdk_aac`. */
export interface AacEncoderMetadata {
  bitrateMode?: number | undefined;
  enableAfterburner?: boolean | undefined;
  signalingMode?: number | undefined;
}

export interface AacDecoderSpecificInfo {
  decoderSpecificInfoDescriptorTag?: number | undefined;
  audioObjectType?: number | undefined;
  sampleFrequencyIndex?: SampleFrequencyIndex | undefined;
  samplingFrequency?: number | undefined;
  channelConfiguration?: number | undefined;
}

export interface AacGaSpecificConfig {
  frameLengthFlag?: boolean | undefined;
  dependsOnCoreCoder?: boolean | undefined;
  extensionFlag?: boolean | undefined;
}

export interface AacDecoderConfig {
  decoderConfigDescriptorTag?: number | undefined;
  objectTypeIndication?: number | undefined;
  streamType?: number | undefined;
  upstream?:
    | boolean
    | undefined;
  /** As per ISO 14496-1:2010. */
  reserved?: boolean | undefined;
  bufferSizeDb?: number | undefined;
  maxBitrate?: number | undefined;
  averageBitRate?: number | undefined;
  decoderSpecificInfo?: AacDecoderSpecificInfo | undefined;
  gaSpecificConfig?: AacGaSpecificConfig | undefined;
  aacEncoderMetadata?: AacEncoderMetadata | undefined;
}

export interface FlacMetaBlockHeader {
  lastMetadataBlockFlag?: boolean | undefined;
  blockType?: FlacBlockType | undefined;
  metadataDataBlockLength?: number | undefined;
}

export interface FlacMetaBlockStreamInfo {
  minimumBlockSize?: number | undefined;
  maximumBlockSize?: number | undefined;
  minimumFrameSize?: number | undefined;
  maximumFrameSize?: number | undefined;
  sampleRate?: number | undefined;
  numberOfChannels?: number | undefined;
  bitsPerSample?: number | undefined;
  totalSamplesInStream?: number | undefined;
  md5Signature?: Uint8Array | undefined;
}

/** Settings to configure `libflac`. */
export interface FlacEncoderMetadata {
  compressionLevel?: number | undefined;
}

export interface FlacMetaBlock {
  header?: FlacMetaBlockHeader | undefined;
  streamInfo?: FlacMetaBlockStreamInfo | undefined;
  genericBlock?: Uint8Array | undefined;
}

export interface FlacDecoderConfig {
  metadataBlocks: FlacMetaBlock[];
  flacEncoderMetadata?: FlacEncoderMetadata | undefined;
}

export interface CodecConfig {
  /** @deprecated */
  deprecatedCodecId?: number | undefined;
  codecId?: CodecId | undefined;
  numSamplesPerFrame?: number | undefined;
  audioRollDistance?: number | undefined;
  decoderConfigLpcm?: LpcmDecoderConfig | undefined;
  decoderConfigOpus?: OpusDecoderConfig | undefined;
  decoderConfigAac?: AacDecoderConfig | undefined;
  decoderConfigFlac?:
    | FlacDecoderConfig
    | undefined;
  /**
   * If true, the codec-delay related fields will be ignored and automatically
   * determined. For example, the OpusDecoderConfig.pre_skip field will be
   * ignored and set to the number of samples reported by the underlying encoder
   * library.
   */
  automaticallyOverrideCodecDelay?:
    | boolean
    | undefined;
  /**
   * If true, the `audio_roll_distance` will be ignored and automatically be set
   * to the correct value.
   */
  automaticallyOverrideAudioRollDistance?: boolean | undefined;
}

export interface CodecConfigObuMetadata {
  codecConfigId?: number | undefined;
  codecConfig?: CodecConfig | undefined;
  obuHeader?: ObuHeaderMetadata | undefined;
}

function createBaseLpcmDecoderConfig(): LpcmDecoderConfig {
  return { sampleFormatFlags: 0, sampleSize: 0, sampleRate: 0 };
}

export const LpcmDecoderConfig: MessageFns<LpcmDecoderConfig> = {
  encode(message: LpcmDecoderConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sampleFormatFlags !== undefined && message.sampleFormatFlags !== 0) {
      writer.uint32(8).int32(message.sampleFormatFlags);
    }
    if (message.sampleSize !== undefined && message.sampleSize !== 0) {
      writer.uint32(16).uint32(message.sampleSize);
    }
    if (message.sampleRate !== undefined && message.sampleRate !== 0) {
      writer.uint32(24).uint32(message.sampleRate);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LpcmDecoderConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLpcmDecoderConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.sampleFormatFlags = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.sampleSize = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.sampleRate = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LpcmDecoderConfig {
    return {
      sampleFormatFlags: isSet(object.sampleFormatFlags) ? lpcmFormatFlagsFromJSON(object.sampleFormatFlags) : 0,
      sampleSize: isSet(object.sampleSize) ? globalThis.Number(object.sampleSize) : 0,
      sampleRate: isSet(object.sampleRate) ? globalThis.Number(object.sampleRate) : 0,
    };
  },

  toJSON(message: LpcmDecoderConfig): unknown {
    const obj: any = {};
    if (message.sampleFormatFlags !== undefined && message.sampleFormatFlags !== 0) {
      obj.sampleFormatFlags = lpcmFormatFlagsToJSON(message.sampleFormatFlags);
    }
    if (message.sampleSize !== undefined && message.sampleSize !== 0) {
      obj.sampleSize = Math.round(message.sampleSize);
    }
    if (message.sampleRate !== undefined && message.sampleRate !== 0) {
      obj.sampleRate = Math.round(message.sampleRate);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LpcmDecoderConfig>, I>>(base?: I): LpcmDecoderConfig {
    return LpcmDecoderConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LpcmDecoderConfig>, I>>(object: I): LpcmDecoderConfig {
    const message = createBaseLpcmDecoderConfig();
    message.sampleFormatFlags = object.sampleFormatFlags ?? 0;
    message.sampleSize = object.sampleSize ?? 0;
    message.sampleRate = object.sampleRate ?? 0;
    return message;
  },
};

function createBaseOpusEncoderMetadata(): OpusEncoderMetadata {
  return {
    application: 0,
    useFloatApi: true,
    targetBitratePerChannel: 0,
    couplingRateAdjustment: 1,
    substreamIdToBitrateOverride: {},
  };
}

export const OpusEncoderMetadata: MessageFns<OpusEncoderMetadata> = {
  encode(message: OpusEncoderMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.application !== undefined && message.application !== 0) {
      writer.uint32(16).int32(message.application);
    }
    if (message.useFloatApi !== undefined && message.useFloatApi !== true) {
      writer.uint32(24).bool(message.useFloatApi);
    }
    if (message.targetBitratePerChannel !== undefined && message.targetBitratePerChannel !== 0) {
      writer.uint32(8).int32(message.targetBitratePerChannel);
    }
    if (message.couplingRateAdjustment !== undefined && message.couplingRateAdjustment !== 1) {
      writer.uint32(37).float(message.couplingRateAdjustment);
    }
    Object.entries(message.substreamIdToBitrateOverride).forEach(([key, value]) => {
      OpusEncoderMetadata_SubstreamIdToBitrateOverrideEntry.encode({ key: key as any, value }, writer.uint32(42).fork())
        .join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OpusEncoderMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOpusEncoderMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.application = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.useFloatApi = reader.bool();
          continue;
        }
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.targetBitratePerChannel = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 37) {
            break;
          }

          message.couplingRateAdjustment = reader.float();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          const entry5 = OpusEncoderMetadata_SubstreamIdToBitrateOverrideEntry.decode(reader, reader.uint32());
          if (entry5.value !== undefined) {
            message.substreamIdToBitrateOverride[entry5.key] = entry5.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OpusEncoderMetadata {
    return {
      application: isSet(object.application) ? opusApplicationFlagFromJSON(object.application) : 0,
      useFloatApi: isSet(object.useFloatApi) ? globalThis.Boolean(object.useFloatApi) : true,
      targetBitratePerChannel: isSet(object.targetBitratePerChannel)
        ? globalThis.Number(object.targetBitratePerChannel)
        : 0,
      couplingRateAdjustment: isSet(object.couplingRateAdjustment)
        ? globalThis.Number(object.couplingRateAdjustment)
        : 1,
      substreamIdToBitrateOverride: isObject(object.substreamIdToBitrateOverride)
        ? Object.entries(object.substreamIdToBitrateOverride).reduce<{ [key: number]: number }>((acc, [key, value]) => {
          acc[globalThis.Number(key)] = Number(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: OpusEncoderMetadata): unknown {
    const obj: any = {};
    if (message.application !== undefined && message.application !== 0) {
      obj.application = opusApplicationFlagToJSON(message.application);
    }
    if (message.useFloatApi !== undefined && message.useFloatApi !== true) {
      obj.useFloatApi = message.useFloatApi;
    }
    if (message.targetBitratePerChannel !== undefined && message.targetBitratePerChannel !== 0) {
      obj.targetBitratePerChannel = Math.round(message.targetBitratePerChannel);
    }
    if (message.couplingRateAdjustment !== undefined && message.couplingRateAdjustment !== 1) {
      obj.couplingRateAdjustment = message.couplingRateAdjustment;
    }
    if (message.substreamIdToBitrateOverride) {
      const entries = Object.entries(message.substreamIdToBitrateOverride);
      if (entries.length > 0) {
        obj.substreamIdToBitrateOverride = {};
        entries.forEach(([k, v]) => {
          obj.substreamIdToBitrateOverride[k] = Math.round(v);
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OpusEncoderMetadata>, I>>(base?: I): OpusEncoderMetadata {
    return OpusEncoderMetadata.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OpusEncoderMetadata>, I>>(object: I): OpusEncoderMetadata {
    const message = createBaseOpusEncoderMetadata();
    message.application = object.application ?? 0;
    message.useFloatApi = object.useFloatApi ?? true;
    message.targetBitratePerChannel = object.targetBitratePerChannel ?? 0;
    message.couplingRateAdjustment = object.couplingRateAdjustment ?? 1;
    message.substreamIdToBitrateOverride = Object.entries(object.substreamIdToBitrateOverride ?? {}).reduce<
      { [key: number]: number }
    >((acc, [key, value]) => {
      if (value !== undefined) {
        acc[globalThis.Number(key)] = globalThis.Number(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseOpusEncoderMetadata_SubstreamIdToBitrateOverrideEntry(): OpusEncoderMetadata_SubstreamIdToBitrateOverrideEntry {
  return { key: 0, value: 0 };
}

export const OpusEncoderMetadata_SubstreamIdToBitrateOverrideEntry: MessageFns<
  OpusEncoderMetadata_SubstreamIdToBitrateOverrideEntry
> = {
  encode(
    message: OpusEncoderMetadata_SubstreamIdToBitrateOverrideEntry,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.key !== 0) {
      writer.uint32(8).uint32(message.key);
    }
    if (message.value !== 0) {
      writer.uint32(16).int32(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OpusEncoderMetadata_SubstreamIdToBitrateOverrideEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOpusEncoderMetadata_SubstreamIdToBitrateOverrideEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.key = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.value = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OpusEncoderMetadata_SubstreamIdToBitrateOverrideEntry {
    return {
      key: isSet(object.key) ? globalThis.Number(object.key) : 0,
      value: isSet(object.value) ? globalThis.Number(object.value) : 0,
    };
  },

  toJSON(message: OpusEncoderMetadata_SubstreamIdToBitrateOverrideEntry): unknown {
    const obj: any = {};
    if (message.key !== 0) {
      obj.key = Math.round(message.key);
    }
    if (message.value !== 0) {
      obj.value = Math.round(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OpusEncoderMetadata_SubstreamIdToBitrateOverrideEntry>, I>>(
    base?: I,
  ): OpusEncoderMetadata_SubstreamIdToBitrateOverrideEntry {
    return OpusEncoderMetadata_SubstreamIdToBitrateOverrideEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OpusEncoderMetadata_SubstreamIdToBitrateOverrideEntry>, I>>(
    object: I,
  ): OpusEncoderMetadata_SubstreamIdToBitrateOverrideEntry {
    const message = createBaseOpusEncoderMetadata_SubstreamIdToBitrateOverrideEntry();
    message.key = object.key ?? 0;
    message.value = object.value ?? 0;
    return message;
  },
};

function createBaseOpusDecoderConfig(): OpusDecoderConfig {
  return {
    version: 0,
    outputChannelCount: 2,
    preSkip: 0,
    inputSampleRate: 0,
    outputGain: 0,
    mappingFamily: 0,
    opusEncoderMetadata: undefined,
  };
}

export const OpusDecoderConfig: MessageFns<OpusDecoderConfig> = {
  encode(message: OpusDecoderConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.version !== undefined && message.version !== 0) {
      writer.uint32(8).uint32(message.version);
    }
    if (message.outputChannelCount !== undefined && message.outputChannelCount !== 2) {
      writer.uint32(16).uint32(message.outputChannelCount);
    }
    if (message.preSkip !== undefined && message.preSkip !== 0) {
      writer.uint32(24).uint32(message.preSkip);
    }
    if (message.inputSampleRate !== undefined && message.inputSampleRate !== 0) {
      writer.uint32(32).uint32(message.inputSampleRate);
    }
    if (message.outputGain !== undefined && message.outputGain !== 0) {
      writer.uint32(40).int32(message.outputGain);
    }
    if (message.mappingFamily !== undefined && message.mappingFamily !== 0) {
      writer.uint32(48).uint32(message.mappingFamily);
    }
    if (message.opusEncoderMetadata !== undefined) {
      OpusEncoderMetadata.encode(message.opusEncoderMetadata, writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OpusDecoderConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOpusDecoderConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.version = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.outputChannelCount = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.preSkip = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.inputSampleRate = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.outputGain = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.mappingFamily = reader.uint32();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.opusEncoderMetadata = OpusEncoderMetadata.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OpusDecoderConfig {
    return {
      version: isSet(object.version) ? globalThis.Number(object.version) : 0,
      outputChannelCount: isSet(object.outputChannelCount) ? globalThis.Number(object.outputChannelCount) : 2,
      preSkip: isSet(object.preSkip) ? globalThis.Number(object.preSkip) : 0,
      inputSampleRate: isSet(object.inputSampleRate) ? globalThis.Number(object.inputSampleRate) : 0,
      outputGain: isSet(object.outputGain) ? globalThis.Number(object.outputGain) : 0,
      mappingFamily: isSet(object.mappingFamily) ? globalThis.Number(object.mappingFamily) : 0,
      opusEncoderMetadata: isSet(object.opusEncoderMetadata)
        ? OpusEncoderMetadata.fromJSON(object.opusEncoderMetadata)
        : undefined,
    };
  },

  toJSON(message: OpusDecoderConfig): unknown {
    const obj: any = {};
    if (message.version !== undefined && message.version !== 0) {
      obj.version = Math.round(message.version);
    }
    if (message.outputChannelCount !== undefined && message.outputChannelCount !== 2) {
      obj.outputChannelCount = Math.round(message.outputChannelCount);
    }
    if (message.preSkip !== undefined && message.preSkip !== 0) {
      obj.preSkip = Math.round(message.preSkip);
    }
    if (message.inputSampleRate !== undefined && message.inputSampleRate !== 0) {
      obj.inputSampleRate = Math.round(message.inputSampleRate);
    }
    if (message.outputGain !== undefined && message.outputGain !== 0) {
      obj.outputGain = Math.round(message.outputGain);
    }
    if (message.mappingFamily !== undefined && message.mappingFamily !== 0) {
      obj.mappingFamily = Math.round(message.mappingFamily);
    }
    if (message.opusEncoderMetadata !== undefined) {
      obj.opusEncoderMetadata = OpusEncoderMetadata.toJSON(message.opusEncoderMetadata);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OpusDecoderConfig>, I>>(base?: I): OpusDecoderConfig {
    return OpusDecoderConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OpusDecoderConfig>, I>>(object: I): OpusDecoderConfig {
    const message = createBaseOpusDecoderConfig();
    message.version = object.version ?? 0;
    message.outputChannelCount = object.outputChannelCount ?? 2;
    message.preSkip = object.preSkip ?? 0;
    message.inputSampleRate = object.inputSampleRate ?? 0;
    message.outputGain = object.outputGain ?? 0;
    message.mappingFamily = object.mappingFamily ?? 0;
    message.opusEncoderMetadata = (object.opusEncoderMetadata !== undefined && object.opusEncoderMetadata !== null)
      ? OpusEncoderMetadata.fromPartial(object.opusEncoderMetadata)
      : undefined;
    return message;
  },
};

function createBaseAacEncoderMetadata(): AacEncoderMetadata {
  return { bitrateMode: 0, enableAfterburner: true, signalingMode: 2 };
}

export const AacEncoderMetadata: MessageFns<AacEncoderMetadata> = {
  encode(message: AacEncoderMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.bitrateMode !== undefined && message.bitrateMode !== 0) {
      writer.uint32(8).int32(message.bitrateMode);
    }
    if (message.enableAfterburner !== undefined && message.enableAfterburner !== true) {
      writer.uint32(16).bool(message.enableAfterburner);
    }
    if (message.signalingMode !== undefined && message.signalingMode !== 2) {
      writer.uint32(24).int32(message.signalingMode);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AacEncoderMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAacEncoderMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.bitrateMode = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.enableAfterburner = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.signalingMode = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AacEncoderMetadata {
    return {
      bitrateMode: isSet(object.bitrateMode) ? globalThis.Number(object.bitrateMode) : 0,
      enableAfterburner: isSet(object.enableAfterburner) ? globalThis.Boolean(object.enableAfterburner) : true,
      signalingMode: isSet(object.signalingMode) ? globalThis.Number(object.signalingMode) : 2,
    };
  },

  toJSON(message: AacEncoderMetadata): unknown {
    const obj: any = {};
    if (message.bitrateMode !== undefined && message.bitrateMode !== 0) {
      obj.bitrateMode = Math.round(message.bitrateMode);
    }
    if (message.enableAfterburner !== undefined && message.enableAfterburner !== true) {
      obj.enableAfterburner = message.enableAfterburner;
    }
    if (message.signalingMode !== undefined && message.signalingMode !== 2) {
      obj.signalingMode = Math.round(message.signalingMode);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AacEncoderMetadata>, I>>(base?: I): AacEncoderMetadata {
    return AacEncoderMetadata.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AacEncoderMetadata>, I>>(object: I): AacEncoderMetadata {
    const message = createBaseAacEncoderMetadata();
    message.bitrateMode = object.bitrateMode ?? 0;
    message.enableAfterburner = object.enableAfterburner ?? true;
    message.signalingMode = object.signalingMode ?? 2;
    return message;
  },
};

function createBaseAacDecoderSpecificInfo(): AacDecoderSpecificInfo {
  return {
    decoderSpecificInfoDescriptorTag: 5,
    audioObjectType: 2,
    sampleFrequencyIndex: 0,
    samplingFrequency: 0,
    channelConfiguration: 2,
  };
}

export const AacDecoderSpecificInfo: MessageFns<AacDecoderSpecificInfo> = {
  encode(message: AacDecoderSpecificInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.decoderSpecificInfoDescriptorTag !== undefined && message.decoderSpecificInfoDescriptorTag !== 5) {
      writer.uint32(40).uint32(message.decoderSpecificInfoDescriptorTag);
    }
    if (message.audioObjectType !== undefined && message.audioObjectType !== 2) {
      writer.uint32(8).uint32(message.audioObjectType);
    }
    if (message.sampleFrequencyIndex !== undefined && message.sampleFrequencyIndex !== 0) {
      writer.uint32(16).int32(message.sampleFrequencyIndex);
    }
    if (message.samplingFrequency !== undefined && message.samplingFrequency !== 0) {
      writer.uint32(24).uint32(message.samplingFrequency);
    }
    if (message.channelConfiguration !== undefined && message.channelConfiguration !== 2) {
      writer.uint32(32).uint32(message.channelConfiguration);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AacDecoderSpecificInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAacDecoderSpecificInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.decoderSpecificInfoDescriptorTag = reader.uint32();
          continue;
        }
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.audioObjectType = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.sampleFrequencyIndex = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.samplingFrequency = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.channelConfiguration = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AacDecoderSpecificInfo {
    return {
      decoderSpecificInfoDescriptorTag: isSet(object.decoderSpecificInfoDescriptorTag)
        ? globalThis.Number(object.decoderSpecificInfoDescriptorTag)
        : 5,
      audioObjectType: isSet(object.audioObjectType) ? globalThis.Number(object.audioObjectType) : 2,
      sampleFrequencyIndex: isSet(object.sampleFrequencyIndex)
        ? sampleFrequencyIndexFromJSON(object.sampleFrequencyIndex)
        : 0,
      samplingFrequency: isSet(object.samplingFrequency) ? globalThis.Number(object.samplingFrequency) : 0,
      channelConfiguration: isSet(object.channelConfiguration) ? globalThis.Number(object.channelConfiguration) : 2,
    };
  },

  toJSON(message: AacDecoderSpecificInfo): unknown {
    const obj: any = {};
    if (message.decoderSpecificInfoDescriptorTag !== undefined && message.decoderSpecificInfoDescriptorTag !== 5) {
      obj.decoderSpecificInfoDescriptorTag = Math.round(message.decoderSpecificInfoDescriptorTag);
    }
    if (message.audioObjectType !== undefined && message.audioObjectType !== 2) {
      obj.audioObjectType = Math.round(message.audioObjectType);
    }
    if (message.sampleFrequencyIndex !== undefined && message.sampleFrequencyIndex !== 0) {
      obj.sampleFrequencyIndex = sampleFrequencyIndexToJSON(message.sampleFrequencyIndex);
    }
    if (message.samplingFrequency !== undefined && message.samplingFrequency !== 0) {
      obj.samplingFrequency = Math.round(message.samplingFrequency);
    }
    if (message.channelConfiguration !== undefined && message.channelConfiguration !== 2) {
      obj.channelConfiguration = Math.round(message.channelConfiguration);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AacDecoderSpecificInfo>, I>>(base?: I): AacDecoderSpecificInfo {
    return AacDecoderSpecificInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AacDecoderSpecificInfo>, I>>(object: I): AacDecoderSpecificInfo {
    const message = createBaseAacDecoderSpecificInfo();
    message.decoderSpecificInfoDescriptorTag = object.decoderSpecificInfoDescriptorTag ?? 5;
    message.audioObjectType = object.audioObjectType ?? 2;
    message.sampleFrequencyIndex = object.sampleFrequencyIndex ?? 0;
    message.samplingFrequency = object.samplingFrequency ?? 0;
    message.channelConfiguration = object.channelConfiguration ?? 2;
    return message;
  },
};

function createBaseAacGaSpecificConfig(): AacGaSpecificConfig {
  return { frameLengthFlag: false, dependsOnCoreCoder: false, extensionFlag: false };
}

export const AacGaSpecificConfig: MessageFns<AacGaSpecificConfig> = {
  encode(message: AacGaSpecificConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.frameLengthFlag !== undefined && message.frameLengthFlag !== false) {
      writer.uint32(8).bool(message.frameLengthFlag);
    }
    if (message.dependsOnCoreCoder !== undefined && message.dependsOnCoreCoder !== false) {
      writer.uint32(16).bool(message.dependsOnCoreCoder);
    }
    if (message.extensionFlag !== undefined && message.extensionFlag !== false) {
      writer.uint32(24).bool(message.extensionFlag);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AacGaSpecificConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAacGaSpecificConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.frameLengthFlag = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.dependsOnCoreCoder = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.extensionFlag = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AacGaSpecificConfig {
    return {
      frameLengthFlag: isSet(object.frameLengthFlag) ? globalThis.Boolean(object.frameLengthFlag) : false,
      dependsOnCoreCoder: isSet(object.dependsOnCoreCoder) ? globalThis.Boolean(object.dependsOnCoreCoder) : false,
      extensionFlag: isSet(object.extensionFlag) ? globalThis.Boolean(object.extensionFlag) : false,
    };
  },

  toJSON(message: AacGaSpecificConfig): unknown {
    const obj: any = {};
    if (message.frameLengthFlag !== undefined && message.frameLengthFlag !== false) {
      obj.frameLengthFlag = message.frameLengthFlag;
    }
    if (message.dependsOnCoreCoder !== undefined && message.dependsOnCoreCoder !== false) {
      obj.dependsOnCoreCoder = message.dependsOnCoreCoder;
    }
    if (message.extensionFlag !== undefined && message.extensionFlag !== false) {
      obj.extensionFlag = message.extensionFlag;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AacGaSpecificConfig>, I>>(base?: I): AacGaSpecificConfig {
    return AacGaSpecificConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AacGaSpecificConfig>, I>>(object: I): AacGaSpecificConfig {
    const message = createBaseAacGaSpecificConfig();
    message.frameLengthFlag = object.frameLengthFlag ?? false;
    message.dependsOnCoreCoder = object.dependsOnCoreCoder ?? false;
    message.extensionFlag = object.extensionFlag ?? false;
    return message;
  },
};

function createBaseAacDecoderConfig(): AacDecoderConfig {
  return {
    decoderConfigDescriptorTag: 4,
    objectTypeIndication: 64,
    streamType: 5,
    upstream: false,
    reserved: true,
    bufferSizeDb: 0,
    maxBitrate: 0,
    averageBitRate: 0,
    decoderSpecificInfo: undefined,
    gaSpecificConfig: undefined,
    aacEncoderMetadata: undefined,
  };
}

export const AacDecoderConfig: MessageFns<AacDecoderConfig> = {
  encode(message: AacDecoderConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.decoderConfigDescriptorTag !== undefined && message.decoderConfigDescriptorTag !== 4) {
      writer.uint32(88).uint32(message.decoderConfigDescriptorTag);
    }
    if (message.objectTypeIndication !== undefined && message.objectTypeIndication !== 64) {
      writer.uint32(8).uint32(message.objectTypeIndication);
    }
    if (message.streamType !== undefined && message.streamType !== 5) {
      writer.uint32(16).uint32(message.streamType);
    }
    if (message.upstream !== undefined && message.upstream !== false) {
      writer.uint32(24).bool(message.upstream);
    }
    if (message.reserved !== undefined && message.reserved !== true) {
      writer.uint32(32).bool(message.reserved);
    }
    if (message.bufferSizeDb !== undefined && message.bufferSizeDb !== 0) {
      writer.uint32(40).uint32(message.bufferSizeDb);
    }
    if (message.maxBitrate !== undefined && message.maxBitrate !== 0) {
      writer.uint32(48).uint32(message.maxBitrate);
    }
    if (message.averageBitRate !== undefined && message.averageBitRate !== 0) {
      writer.uint32(56).uint32(message.averageBitRate);
    }
    if (message.decoderSpecificInfo !== undefined) {
      AacDecoderSpecificInfo.encode(message.decoderSpecificInfo, writer.uint32(66).fork()).join();
    }
    if (message.gaSpecificConfig !== undefined) {
      AacGaSpecificConfig.encode(message.gaSpecificConfig, writer.uint32(74).fork()).join();
    }
    if (message.aacEncoderMetadata !== undefined) {
      AacEncoderMetadata.encode(message.aacEncoderMetadata, writer.uint32(82).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AacDecoderConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAacDecoderConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.decoderConfigDescriptorTag = reader.uint32();
          continue;
        }
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.objectTypeIndication = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.streamType = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.upstream = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.reserved = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.bufferSizeDb = reader.uint32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.maxBitrate = reader.uint32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.averageBitRate = reader.uint32();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.decoderSpecificInfo = AacDecoderSpecificInfo.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.gaSpecificConfig = AacGaSpecificConfig.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.aacEncoderMetadata = AacEncoderMetadata.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AacDecoderConfig {
    return {
      decoderConfigDescriptorTag: isSet(object.decoderConfigDescriptorTag)
        ? globalThis.Number(object.decoderConfigDescriptorTag)
        : 4,
      objectTypeIndication: isSet(object.objectTypeIndication) ? globalThis.Number(object.objectTypeIndication) : 64,
      streamType: isSet(object.streamType) ? globalThis.Number(object.streamType) : 5,
      upstream: isSet(object.upstream) ? globalThis.Boolean(object.upstream) : false,
      reserved: isSet(object.reserved) ? globalThis.Boolean(object.reserved) : true,
      bufferSizeDb: isSet(object.bufferSizeDb) ? globalThis.Number(object.bufferSizeDb) : 0,
      maxBitrate: isSet(object.maxBitrate) ? globalThis.Number(object.maxBitrate) : 0,
      averageBitRate: isSet(object.averageBitRate) ? globalThis.Number(object.averageBitRate) : 0,
      decoderSpecificInfo: isSet(object.decoderSpecificInfo)
        ? AacDecoderSpecificInfo.fromJSON(object.decoderSpecificInfo)
        : undefined,
      gaSpecificConfig: isSet(object.gaSpecificConfig)
        ? AacGaSpecificConfig.fromJSON(object.gaSpecificConfig)
        : undefined,
      aacEncoderMetadata: isSet(object.aacEncoderMetadata)
        ? AacEncoderMetadata.fromJSON(object.aacEncoderMetadata)
        : undefined,
    };
  },

  toJSON(message: AacDecoderConfig): unknown {
    const obj: any = {};
    if (message.decoderConfigDescriptorTag !== undefined && message.decoderConfigDescriptorTag !== 4) {
      obj.decoderConfigDescriptorTag = Math.round(message.decoderConfigDescriptorTag);
    }
    if (message.objectTypeIndication !== undefined && message.objectTypeIndication !== 64) {
      obj.objectTypeIndication = Math.round(message.objectTypeIndication);
    }
    if (message.streamType !== undefined && message.streamType !== 5) {
      obj.streamType = Math.round(message.streamType);
    }
    if (message.upstream !== undefined && message.upstream !== false) {
      obj.upstream = message.upstream;
    }
    if (message.reserved !== undefined && message.reserved !== true) {
      obj.reserved = message.reserved;
    }
    if (message.bufferSizeDb !== undefined && message.bufferSizeDb !== 0) {
      obj.bufferSizeDb = Math.round(message.bufferSizeDb);
    }
    if (message.maxBitrate !== undefined && message.maxBitrate !== 0) {
      obj.maxBitrate = Math.round(message.maxBitrate);
    }
    if (message.averageBitRate !== undefined && message.averageBitRate !== 0) {
      obj.averageBitRate = Math.round(message.averageBitRate);
    }
    if (message.decoderSpecificInfo !== undefined) {
      obj.decoderSpecificInfo = AacDecoderSpecificInfo.toJSON(message.decoderSpecificInfo);
    }
    if (message.gaSpecificConfig !== undefined) {
      obj.gaSpecificConfig = AacGaSpecificConfig.toJSON(message.gaSpecificConfig);
    }
    if (message.aacEncoderMetadata !== undefined) {
      obj.aacEncoderMetadata = AacEncoderMetadata.toJSON(message.aacEncoderMetadata);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AacDecoderConfig>, I>>(base?: I): AacDecoderConfig {
    return AacDecoderConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AacDecoderConfig>, I>>(object: I): AacDecoderConfig {
    const message = createBaseAacDecoderConfig();
    message.decoderConfigDescriptorTag = object.decoderConfigDescriptorTag ?? 4;
    message.objectTypeIndication = object.objectTypeIndication ?? 64;
    message.streamType = object.streamType ?? 5;
    message.upstream = object.upstream ?? false;
    message.reserved = object.reserved ?? true;
    message.bufferSizeDb = object.bufferSizeDb ?? 0;
    message.maxBitrate = object.maxBitrate ?? 0;
    message.averageBitRate = object.averageBitRate ?? 0;
    message.decoderSpecificInfo = (object.decoderSpecificInfo !== undefined && object.decoderSpecificInfo !== null)
      ? AacDecoderSpecificInfo.fromPartial(object.decoderSpecificInfo)
      : undefined;
    message.gaSpecificConfig = (object.gaSpecificConfig !== undefined && object.gaSpecificConfig !== null)
      ? AacGaSpecificConfig.fromPartial(object.gaSpecificConfig)
      : undefined;
    message.aacEncoderMetadata = (object.aacEncoderMetadata !== undefined && object.aacEncoderMetadata !== null)
      ? AacEncoderMetadata.fromPartial(object.aacEncoderMetadata)
      : undefined;
    return message;
  },
};

function createBaseFlacMetaBlockHeader(): FlacMetaBlockHeader {
  return { lastMetadataBlockFlag: false, blockType: 0, metadataDataBlockLength: 0 };
}

export const FlacMetaBlockHeader: MessageFns<FlacMetaBlockHeader> = {
  encode(message: FlacMetaBlockHeader, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.lastMetadataBlockFlag !== undefined && message.lastMetadataBlockFlag !== false) {
      writer.uint32(8).bool(message.lastMetadataBlockFlag);
    }
    if (message.blockType !== undefined && message.blockType !== 0) {
      writer.uint32(16).int32(message.blockType);
    }
    if (message.metadataDataBlockLength !== undefined && message.metadataDataBlockLength !== 0) {
      writer.uint32(24).uint32(message.metadataDataBlockLength);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FlacMetaBlockHeader {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFlacMetaBlockHeader();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.lastMetadataBlockFlag = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.blockType = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.metadataDataBlockLength = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FlacMetaBlockHeader {
    return {
      lastMetadataBlockFlag: isSet(object.lastMetadataBlockFlag)
        ? globalThis.Boolean(object.lastMetadataBlockFlag)
        : false,
      blockType: isSet(object.blockType) ? flacBlockTypeFromJSON(object.blockType) : 0,
      metadataDataBlockLength: isSet(object.metadataDataBlockLength)
        ? globalThis.Number(object.metadataDataBlockLength)
        : 0,
    };
  },

  toJSON(message: FlacMetaBlockHeader): unknown {
    const obj: any = {};
    if (message.lastMetadataBlockFlag !== undefined && message.lastMetadataBlockFlag !== false) {
      obj.lastMetadataBlockFlag = message.lastMetadataBlockFlag;
    }
    if (message.blockType !== undefined && message.blockType !== 0) {
      obj.blockType = flacBlockTypeToJSON(message.blockType);
    }
    if (message.metadataDataBlockLength !== undefined && message.metadataDataBlockLength !== 0) {
      obj.metadataDataBlockLength = Math.round(message.metadataDataBlockLength);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FlacMetaBlockHeader>, I>>(base?: I): FlacMetaBlockHeader {
    return FlacMetaBlockHeader.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FlacMetaBlockHeader>, I>>(object: I): FlacMetaBlockHeader {
    const message = createBaseFlacMetaBlockHeader();
    message.lastMetadataBlockFlag = object.lastMetadataBlockFlag ?? false;
    message.blockType = object.blockType ?? 0;
    message.metadataDataBlockLength = object.metadataDataBlockLength ?? 0;
    return message;
  },
};

function createBaseFlacMetaBlockStreamInfo(): FlacMetaBlockStreamInfo {
  return {
    minimumBlockSize: 0,
    maximumBlockSize: 0,
    minimumFrameSize: 0,
    maximumFrameSize: 0,
    sampleRate: 0,
    numberOfChannels: 1,
    bitsPerSample: 0,
    totalSamplesInStream: 0,
    md5Signature: new Uint8Array(0),
  };
}

export const FlacMetaBlockStreamInfo: MessageFns<FlacMetaBlockStreamInfo> = {
  encode(message: FlacMetaBlockStreamInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.minimumBlockSize !== undefined && message.minimumBlockSize !== 0) {
      writer.uint32(8).uint32(message.minimumBlockSize);
    }
    if (message.maximumBlockSize !== undefined && message.maximumBlockSize !== 0) {
      writer.uint32(16).uint32(message.maximumBlockSize);
    }
    if (message.minimumFrameSize !== undefined && message.minimumFrameSize !== 0) {
      writer.uint32(24).uint32(message.minimumFrameSize);
    }
    if (message.maximumFrameSize !== undefined && message.maximumFrameSize !== 0) {
      writer.uint32(32).uint32(message.maximumFrameSize);
    }
    if (message.sampleRate !== undefined && message.sampleRate !== 0) {
      writer.uint32(40).uint32(message.sampleRate);
    }
    if (message.numberOfChannels !== undefined && message.numberOfChannels !== 1) {
      writer.uint32(48).uint32(message.numberOfChannels);
    }
    if (message.bitsPerSample !== undefined && message.bitsPerSample !== 0) {
      writer.uint32(56).uint32(message.bitsPerSample);
    }
    if (message.totalSamplesInStream !== undefined && message.totalSamplesInStream !== 0) {
      writer.uint32(64).uint64(message.totalSamplesInStream);
    }
    if (message.md5Signature !== undefined && message.md5Signature.length !== 0) {
      writer.uint32(74).bytes(message.md5Signature);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FlacMetaBlockStreamInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFlacMetaBlockStreamInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.minimumBlockSize = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.maximumBlockSize = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.minimumFrameSize = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.maximumFrameSize = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.sampleRate = reader.uint32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.numberOfChannels = reader.uint32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.bitsPerSample = reader.uint32();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.totalSamplesInStream = longToNumber(reader.uint64());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.md5Signature = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FlacMetaBlockStreamInfo {
    return {
      minimumBlockSize: isSet(object.minimumBlockSize) ? globalThis.Number(object.minimumBlockSize) : 0,
      maximumBlockSize: isSet(object.maximumBlockSize) ? globalThis.Number(object.maximumBlockSize) : 0,
      minimumFrameSize: isSet(object.minimumFrameSize) ? globalThis.Number(object.minimumFrameSize) : 0,
      maximumFrameSize: isSet(object.maximumFrameSize) ? globalThis.Number(object.maximumFrameSize) : 0,
      sampleRate: isSet(object.sampleRate) ? globalThis.Number(object.sampleRate) : 0,
      numberOfChannels: isSet(object.numberOfChannels) ? globalThis.Number(object.numberOfChannels) : 1,
      bitsPerSample: isSet(object.bitsPerSample) ? globalThis.Number(object.bitsPerSample) : 0,
      totalSamplesInStream: isSet(object.totalSamplesInStream) ? globalThis.Number(object.totalSamplesInStream) : 0,
      md5Signature: isSet(object.md5Signature) ? bytesFromBase64(object.md5Signature) : new Uint8Array(0),
    };
  },

  toJSON(message: FlacMetaBlockStreamInfo): unknown {
    const obj: any = {};
    if (message.minimumBlockSize !== undefined && message.minimumBlockSize !== 0) {
      obj.minimumBlockSize = Math.round(message.minimumBlockSize);
    }
    if (message.maximumBlockSize !== undefined && message.maximumBlockSize !== 0) {
      obj.maximumBlockSize = Math.round(message.maximumBlockSize);
    }
    if (message.minimumFrameSize !== undefined && message.minimumFrameSize !== 0) {
      obj.minimumFrameSize = Math.round(message.minimumFrameSize);
    }
    if (message.maximumFrameSize !== undefined && message.maximumFrameSize !== 0) {
      obj.maximumFrameSize = Math.round(message.maximumFrameSize);
    }
    if (message.sampleRate !== undefined && message.sampleRate !== 0) {
      obj.sampleRate = Math.round(message.sampleRate);
    }
    if (message.numberOfChannels !== undefined && message.numberOfChannels !== 1) {
      obj.numberOfChannels = Math.round(message.numberOfChannels);
    }
    if (message.bitsPerSample !== undefined && message.bitsPerSample !== 0) {
      obj.bitsPerSample = Math.round(message.bitsPerSample);
    }
    if (message.totalSamplesInStream !== undefined && message.totalSamplesInStream !== 0) {
      obj.totalSamplesInStream = Math.round(message.totalSamplesInStream);
    }
    if (message.md5Signature !== undefined && message.md5Signature.length !== 0) {
      obj.md5Signature = base64FromBytes(message.md5Signature);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FlacMetaBlockStreamInfo>, I>>(base?: I): FlacMetaBlockStreamInfo {
    return FlacMetaBlockStreamInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FlacMetaBlockStreamInfo>, I>>(object: I): FlacMetaBlockStreamInfo {
    const message = createBaseFlacMetaBlockStreamInfo();
    message.minimumBlockSize = object.minimumBlockSize ?? 0;
    message.maximumBlockSize = object.maximumBlockSize ?? 0;
    message.minimumFrameSize = object.minimumFrameSize ?? 0;
    message.maximumFrameSize = object.maximumFrameSize ?? 0;
    message.sampleRate = object.sampleRate ?? 0;
    message.numberOfChannels = object.numberOfChannels ?? 1;
    message.bitsPerSample = object.bitsPerSample ?? 0;
    message.totalSamplesInStream = object.totalSamplesInStream ?? 0;
    message.md5Signature = object.md5Signature ?? new Uint8Array(0);
    return message;
  },
};

function createBaseFlacEncoderMetadata(): FlacEncoderMetadata {
  return { compressionLevel: 0 };
}

export const FlacEncoderMetadata: MessageFns<FlacEncoderMetadata> = {
  encode(message: FlacEncoderMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.compressionLevel !== undefined && message.compressionLevel !== 0) {
      writer.uint32(8).uint32(message.compressionLevel);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FlacEncoderMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFlacEncoderMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.compressionLevel = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FlacEncoderMetadata {
    return { compressionLevel: isSet(object.compressionLevel) ? globalThis.Number(object.compressionLevel) : 0 };
  },

  toJSON(message: FlacEncoderMetadata): unknown {
    const obj: any = {};
    if (message.compressionLevel !== undefined && message.compressionLevel !== 0) {
      obj.compressionLevel = Math.round(message.compressionLevel);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FlacEncoderMetadata>, I>>(base?: I): FlacEncoderMetadata {
    return FlacEncoderMetadata.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FlacEncoderMetadata>, I>>(object: I): FlacEncoderMetadata {
    const message = createBaseFlacEncoderMetadata();
    message.compressionLevel = object.compressionLevel ?? 0;
    return message;
  },
};

function createBaseFlacMetaBlock(): FlacMetaBlock {
  return { header: undefined, streamInfo: undefined, genericBlock: undefined };
}

export const FlacMetaBlock: MessageFns<FlacMetaBlock> = {
  encode(message: FlacMetaBlock, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.header !== undefined) {
      FlacMetaBlockHeader.encode(message.header, writer.uint32(10).fork()).join();
    }
    if (message.streamInfo !== undefined) {
      FlacMetaBlockStreamInfo.encode(message.streamInfo, writer.uint32(18).fork()).join();
    }
    if (message.genericBlock !== undefined) {
      writer.uint32(26).bytes(message.genericBlock);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FlacMetaBlock {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFlacMetaBlock();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.header = FlacMetaBlockHeader.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.streamInfo = FlacMetaBlockStreamInfo.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.genericBlock = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FlacMetaBlock {
    return {
      header: isSet(object.header) ? FlacMetaBlockHeader.fromJSON(object.header) : undefined,
      streamInfo: isSet(object.streamInfo) ? FlacMetaBlockStreamInfo.fromJSON(object.streamInfo) : undefined,
      genericBlock: isSet(object.genericBlock) ? bytesFromBase64(object.genericBlock) : undefined,
    };
  },

  toJSON(message: FlacMetaBlock): unknown {
    const obj: any = {};
    if (message.header !== undefined) {
      obj.header = FlacMetaBlockHeader.toJSON(message.header);
    }
    if (message.streamInfo !== undefined) {
      obj.streamInfo = FlacMetaBlockStreamInfo.toJSON(message.streamInfo);
    }
    if (message.genericBlock !== undefined) {
      obj.genericBlock = base64FromBytes(message.genericBlock);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FlacMetaBlock>, I>>(base?: I): FlacMetaBlock {
    return FlacMetaBlock.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FlacMetaBlock>, I>>(object: I): FlacMetaBlock {
    const message = createBaseFlacMetaBlock();
    message.header = (object.header !== undefined && object.header !== null)
      ? FlacMetaBlockHeader.fromPartial(object.header)
      : undefined;
    message.streamInfo = (object.streamInfo !== undefined && object.streamInfo !== null)
      ? FlacMetaBlockStreamInfo.fromPartial(object.streamInfo)
      : undefined;
    message.genericBlock = object.genericBlock ?? undefined;
    return message;
  },
};

function createBaseFlacDecoderConfig(): FlacDecoderConfig {
  return { metadataBlocks: [], flacEncoderMetadata: undefined };
}

export const FlacDecoderConfig: MessageFns<FlacDecoderConfig> = {
  encode(message: FlacDecoderConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.metadataBlocks) {
      FlacMetaBlock.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.flacEncoderMetadata !== undefined) {
      FlacEncoderMetadata.encode(message.flacEncoderMetadata, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FlacDecoderConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFlacDecoderConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.metadataBlocks.push(FlacMetaBlock.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.flacEncoderMetadata = FlacEncoderMetadata.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FlacDecoderConfig {
    return {
      metadataBlocks: globalThis.Array.isArray(object?.metadataBlocks)
        ? object.metadataBlocks.map((e: any) => FlacMetaBlock.fromJSON(e))
        : [],
      flacEncoderMetadata: isSet(object.flacEncoderMetadata)
        ? FlacEncoderMetadata.fromJSON(object.flacEncoderMetadata)
        : undefined,
    };
  },

  toJSON(message: FlacDecoderConfig): unknown {
    const obj: any = {};
    if (message.metadataBlocks?.length) {
      obj.metadataBlocks = message.metadataBlocks.map((e) => FlacMetaBlock.toJSON(e));
    }
    if (message.flacEncoderMetadata !== undefined) {
      obj.flacEncoderMetadata = FlacEncoderMetadata.toJSON(message.flacEncoderMetadata);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FlacDecoderConfig>, I>>(base?: I): FlacDecoderConfig {
    return FlacDecoderConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FlacDecoderConfig>, I>>(object: I): FlacDecoderConfig {
    const message = createBaseFlacDecoderConfig();
    message.metadataBlocks = object.metadataBlocks?.map((e) => FlacMetaBlock.fromPartial(e)) || [];
    message.flacEncoderMetadata = (object.flacEncoderMetadata !== undefined && object.flacEncoderMetadata !== null)
      ? FlacEncoderMetadata.fromPartial(object.flacEncoderMetadata)
      : undefined;
    return message;
  },
};

function createBaseCodecConfig(): CodecConfig {
  return {
    deprecatedCodecId: 0,
    codecId: 0,
    numSamplesPerFrame: 0,
    audioRollDistance: 0,
    decoderConfigLpcm: undefined,
    decoderConfigOpus: undefined,
    decoderConfigAac: undefined,
    decoderConfigFlac: undefined,
    automaticallyOverrideCodecDelay: true,
    automaticallyOverrideAudioRollDistance: true,
  };
}

export const CodecConfig: MessageFns<CodecConfig> = {
  encode(message: CodecConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.deprecatedCodecId !== undefined && message.deprecatedCodecId !== 0) {
      writer.uint32(8).uint32(message.deprecatedCodecId);
    }
    if (message.codecId !== undefined && message.codecId !== 0) {
      writer.uint32(80).int32(message.codecId);
    }
    if (message.numSamplesPerFrame !== undefined && message.numSamplesPerFrame !== 0) {
      writer.uint32(16).uint32(message.numSamplesPerFrame);
    }
    if (message.audioRollDistance !== undefined && message.audioRollDistance !== 0) {
      writer.uint32(72).int32(message.audioRollDistance);
    }
    if (message.decoderConfigLpcm !== undefined) {
      LpcmDecoderConfig.encode(message.decoderConfigLpcm, writer.uint32(42).fork()).join();
    }
    if (message.decoderConfigOpus !== undefined) {
      OpusDecoderConfig.encode(message.decoderConfigOpus, writer.uint32(50).fork()).join();
    }
    if (message.decoderConfigAac !== undefined) {
      AacDecoderConfig.encode(message.decoderConfigAac, writer.uint32(58).fork()).join();
    }
    if (message.decoderConfigFlac !== undefined) {
      FlacDecoderConfig.encode(message.decoderConfigFlac, writer.uint32(66).fork()).join();
    }
    if (message.automaticallyOverrideCodecDelay !== undefined && message.automaticallyOverrideCodecDelay !== true) {
      writer.uint32(88).bool(message.automaticallyOverrideCodecDelay);
    }
    if (
      message.automaticallyOverrideAudioRollDistance !== undefined &&
      message.automaticallyOverrideAudioRollDistance !== true
    ) {
      writer.uint32(96).bool(message.automaticallyOverrideAudioRollDistance);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CodecConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCodecConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.deprecatedCodecId = reader.uint32();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.codecId = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.numSamplesPerFrame = reader.uint32();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.audioRollDistance = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.decoderConfigLpcm = LpcmDecoderConfig.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.decoderConfigOpus = OpusDecoderConfig.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.decoderConfigAac = AacDecoderConfig.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.decoderConfigFlac = FlacDecoderConfig.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.automaticallyOverrideCodecDelay = reader.bool();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.automaticallyOverrideAudioRollDistance = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CodecConfig {
    return {
      deprecatedCodecId: isSet(object.deprecatedCodecId) ? globalThis.Number(object.deprecatedCodecId) : 0,
      codecId: isSet(object.codecId) ? codecIdFromJSON(object.codecId) : 0,
      numSamplesPerFrame: isSet(object.numSamplesPerFrame) ? globalThis.Number(object.numSamplesPerFrame) : 0,
      audioRollDistance: isSet(object.audioRollDistance) ? globalThis.Number(object.audioRollDistance) : 0,
      decoderConfigLpcm: isSet(object.decoderConfigLpcm)
        ? LpcmDecoderConfig.fromJSON(object.decoderConfigLpcm)
        : undefined,
      decoderConfigOpus: isSet(object.decoderConfigOpus)
        ? OpusDecoderConfig.fromJSON(object.decoderConfigOpus)
        : undefined,
      decoderConfigAac: isSet(object.decoderConfigAac) ? AacDecoderConfig.fromJSON(object.decoderConfigAac) : undefined,
      decoderConfigFlac: isSet(object.decoderConfigFlac)
        ? FlacDecoderConfig.fromJSON(object.decoderConfigFlac)
        : undefined,
      automaticallyOverrideCodecDelay: isSet(object.automaticallyOverrideCodecDelay)
        ? globalThis.Boolean(object.automaticallyOverrideCodecDelay)
        : true,
      automaticallyOverrideAudioRollDistance: isSet(object.automaticallyOverrideAudioRollDistance)
        ? globalThis.Boolean(object.automaticallyOverrideAudioRollDistance)
        : true,
    };
  },

  toJSON(message: CodecConfig): unknown {
    const obj: any = {};
    if (message.deprecatedCodecId !== undefined && message.deprecatedCodecId !== 0) {
      obj.deprecatedCodecId = Math.round(message.deprecatedCodecId);
    }
    if (message.codecId !== undefined && message.codecId !== 0) {
      obj.codecId = codecIdToJSON(message.codecId);
    }
    if (message.numSamplesPerFrame !== undefined && message.numSamplesPerFrame !== 0) {
      obj.numSamplesPerFrame = Math.round(message.numSamplesPerFrame);
    }
    if (message.audioRollDistance !== undefined && message.audioRollDistance !== 0) {
      obj.audioRollDistance = Math.round(message.audioRollDistance);
    }
    if (message.decoderConfigLpcm !== undefined) {
      obj.decoderConfigLpcm = LpcmDecoderConfig.toJSON(message.decoderConfigLpcm);
    }
    if (message.decoderConfigOpus !== undefined) {
      obj.decoderConfigOpus = OpusDecoderConfig.toJSON(message.decoderConfigOpus);
    }
    if (message.decoderConfigAac !== undefined) {
      obj.decoderConfigAac = AacDecoderConfig.toJSON(message.decoderConfigAac);
    }
    if (message.decoderConfigFlac !== undefined) {
      obj.decoderConfigFlac = FlacDecoderConfig.toJSON(message.decoderConfigFlac);
    }
    if (message.automaticallyOverrideCodecDelay !== undefined && message.automaticallyOverrideCodecDelay !== true) {
      obj.automaticallyOverrideCodecDelay = message.automaticallyOverrideCodecDelay;
    }
    if (
      message.automaticallyOverrideAudioRollDistance !== undefined &&
      message.automaticallyOverrideAudioRollDistance !== true
    ) {
      obj.automaticallyOverrideAudioRollDistance = message.automaticallyOverrideAudioRollDistance;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CodecConfig>, I>>(base?: I): CodecConfig {
    return CodecConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CodecConfig>, I>>(object: I): CodecConfig {
    const message = createBaseCodecConfig();
    message.deprecatedCodecId = object.deprecatedCodecId ?? 0;
    message.codecId = object.codecId ?? 0;
    message.numSamplesPerFrame = object.numSamplesPerFrame ?? 0;
    message.audioRollDistance = object.audioRollDistance ?? 0;
    message.decoderConfigLpcm = (object.decoderConfigLpcm !== undefined && object.decoderConfigLpcm !== null)
      ? LpcmDecoderConfig.fromPartial(object.decoderConfigLpcm)
      : undefined;
    message.decoderConfigOpus = (object.decoderConfigOpus !== undefined && object.decoderConfigOpus !== null)
      ? OpusDecoderConfig.fromPartial(object.decoderConfigOpus)
      : undefined;
    message.decoderConfigAac = (object.decoderConfigAac !== undefined && object.decoderConfigAac !== null)
      ? AacDecoderConfig.fromPartial(object.decoderConfigAac)
      : undefined;
    message.decoderConfigFlac = (object.decoderConfigFlac !== undefined && object.decoderConfigFlac !== null)
      ? FlacDecoderConfig.fromPartial(object.decoderConfigFlac)
      : undefined;
    message.automaticallyOverrideCodecDelay = object.automaticallyOverrideCodecDelay ?? true;
    message.automaticallyOverrideAudioRollDistance = object.automaticallyOverrideAudioRollDistance ?? true;
    return message;
  },
};

function createBaseCodecConfigObuMetadata(): CodecConfigObuMetadata {
  return { codecConfigId: 0, codecConfig: undefined, obuHeader: undefined };
}

export const CodecConfigObuMetadata: MessageFns<CodecConfigObuMetadata> = {
  encode(message: CodecConfigObuMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.codecConfigId !== undefined && message.codecConfigId !== 0) {
      writer.uint32(8).uint32(message.codecConfigId);
    }
    if (message.codecConfig !== undefined) {
      CodecConfig.encode(message.codecConfig, writer.uint32(18).fork()).join();
    }
    if (message.obuHeader !== undefined) {
      ObuHeaderMetadata.encode(message.obuHeader, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CodecConfigObuMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCodecConfigObuMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.codecConfigId = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.codecConfig = CodecConfig.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.obuHeader = ObuHeaderMetadata.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CodecConfigObuMetadata {
    return {
      codecConfigId: isSet(object.codecConfigId) ? globalThis.Number(object.codecConfigId) : 0,
      codecConfig: isSet(object.codecConfig) ? CodecConfig.fromJSON(object.codecConfig) : undefined,
      obuHeader: isSet(object.obuHeader) ? ObuHeaderMetadata.fromJSON(object.obuHeader) : undefined,
    };
  },

  toJSON(message: CodecConfigObuMetadata): unknown {
    const obj: any = {};
    if (message.codecConfigId !== undefined && message.codecConfigId !== 0) {
      obj.codecConfigId = Math.round(message.codecConfigId);
    }
    if (message.codecConfig !== undefined) {
      obj.codecConfig = CodecConfig.toJSON(message.codecConfig);
    }
    if (message.obuHeader !== undefined) {
      obj.obuHeader = ObuHeaderMetadata.toJSON(message.obuHeader);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CodecConfigObuMetadata>, I>>(base?: I): CodecConfigObuMetadata {
    return CodecConfigObuMetadata.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CodecConfigObuMetadata>, I>>(object: I): CodecConfigObuMetadata {
    const message = createBaseCodecConfigObuMetadata();
    message.codecConfigId = object.codecConfigId ?? 0;
    message.codecConfig = (object.codecConfig !== undefined && object.codecConfig !== null)
      ? CodecConfig.fromPartial(object.codecConfig)
      : undefined;
    message.obuHeader = (object.obuHeader !== undefined && object.obuHeader !== null)
      ? ObuHeaderMetadata.fromPartial(object.obuHeader)
      : undefined;
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
