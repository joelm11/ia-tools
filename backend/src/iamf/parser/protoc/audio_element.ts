// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.0
//   protoc               v5.29.3
// source: audio_element.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { ObuHeaderMetadata } from "./obu_header";
import {
  DemixingParamDefinition,
  ParamDefinitionType,
  paramDefinitionTypeFromJSON,
  paramDefinitionTypeToJSON,
  ReconGainParamDefinition,
} from "./param_definitions";

export const protobufPackage = "iamf_tools_cli_proto";

export enum AudioElementType {
  AUDIO_ELEMENT_INVALID = 0,
  AUDIO_ELEMENT_CHANNEL_BASED = 1,
  AUDIO_ELEMENT_SCENE_BASED = 2,
  UNRECOGNIZED = -1,
}

export function audioElementTypeFromJSON(object: any): AudioElementType {
  switch (object) {
    case 0:
    case "AUDIO_ELEMENT_INVALID":
      return AudioElementType.AUDIO_ELEMENT_INVALID;
    case 1:
    case "AUDIO_ELEMENT_CHANNEL_BASED":
      return AudioElementType.AUDIO_ELEMENT_CHANNEL_BASED;
    case 2:
    case "AUDIO_ELEMENT_SCENE_BASED":
      return AudioElementType.AUDIO_ELEMENT_SCENE_BASED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return AudioElementType.UNRECOGNIZED;
  }
}

export function audioElementTypeToJSON(object: AudioElementType): string {
  switch (object) {
    case AudioElementType.AUDIO_ELEMENT_INVALID:
      return "AUDIO_ELEMENT_INVALID";
    case AudioElementType.AUDIO_ELEMENT_CHANNEL_BASED:
      return "AUDIO_ELEMENT_CHANNEL_BASED";
    case AudioElementType.AUDIO_ELEMENT_SCENE_BASED:
      return "AUDIO_ELEMENT_SCENE_BASED";
    case AudioElementType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Valid proto enums start at index 1, which are different from the
 * corresponding enums in C++, e.g. kLayoutMono = 0.
 */
export enum LoudspeakerLayout {
  LOUDSPEAKER_LAYOUT_INVALID = 0,
  LOUDSPEAKER_LAYOUT_MONO = 1,
  LOUDSPEAKER_LAYOUT_STEREO = 2,
  LOUDSPEAKER_LAYOUT_5_1_CH = 3,
  LOUDSPEAKER_LAYOUT_5_1_2_CH = 4,
  LOUDSPEAKER_LAYOUT_5_1_4_CH = 5,
  LOUDSPEAKER_LAYOUT_7_1_CH = 6,
  LOUDSPEAKER_LAYOUT_7_1_2_CH = 7,
  LOUDSPEAKER_LAYOUT_7_1_4_CH = 8,
  LOUDSPEAKER_LAYOUT_3_1_2_CH = 9,
  LOUDSPEAKER_LAYOUT_BINAURAL = 10,
  LOUDSPEAKER_LAYOUT_RESERVED_10 = 11,
  LOUDSPEAKER_LAYOUT_RESERVED_14 = 15,
  LOUDSPEAKER_LAYOUT_EXPANDED = 16,
  UNRECOGNIZED = -1,
}

export function loudspeakerLayoutFromJSON(object: any): LoudspeakerLayout {
  switch (object) {
    case 0:
    case "LOUDSPEAKER_LAYOUT_INVALID":
      return LoudspeakerLayout.LOUDSPEAKER_LAYOUT_INVALID;
    case 1:
    case "LOUDSPEAKER_LAYOUT_MONO":
      return LoudspeakerLayout.LOUDSPEAKER_LAYOUT_MONO;
    case 2:
    case "LOUDSPEAKER_LAYOUT_STEREO":
      return LoudspeakerLayout.LOUDSPEAKER_LAYOUT_STEREO;
    case 3:
    case "LOUDSPEAKER_LAYOUT_5_1_CH":
      return LoudspeakerLayout.LOUDSPEAKER_LAYOUT_5_1_CH;
    case 4:
    case "LOUDSPEAKER_LAYOUT_5_1_2_CH":
      return LoudspeakerLayout.LOUDSPEAKER_LAYOUT_5_1_2_CH;
    case 5:
    case "LOUDSPEAKER_LAYOUT_5_1_4_CH":
      return LoudspeakerLayout.LOUDSPEAKER_LAYOUT_5_1_4_CH;
    case 6:
    case "LOUDSPEAKER_LAYOUT_7_1_CH":
      return LoudspeakerLayout.LOUDSPEAKER_LAYOUT_7_1_CH;
    case 7:
    case "LOUDSPEAKER_LAYOUT_7_1_2_CH":
      return LoudspeakerLayout.LOUDSPEAKER_LAYOUT_7_1_2_CH;
    case 8:
    case "LOUDSPEAKER_LAYOUT_7_1_4_CH":
      return LoudspeakerLayout.LOUDSPEAKER_LAYOUT_7_1_4_CH;
    case 9:
    case "LOUDSPEAKER_LAYOUT_3_1_2_CH":
      return LoudspeakerLayout.LOUDSPEAKER_LAYOUT_3_1_2_CH;
    case 10:
    case "LOUDSPEAKER_LAYOUT_BINAURAL":
      return LoudspeakerLayout.LOUDSPEAKER_LAYOUT_BINAURAL;
    case 11:
    case "LOUDSPEAKER_LAYOUT_RESERVED_10":
      return LoudspeakerLayout.LOUDSPEAKER_LAYOUT_RESERVED_10;
    case 15:
    case "LOUDSPEAKER_LAYOUT_RESERVED_14":
      return LoudspeakerLayout.LOUDSPEAKER_LAYOUT_RESERVED_14;
    case 16:
    case "LOUDSPEAKER_LAYOUT_EXPANDED":
      return LoudspeakerLayout.LOUDSPEAKER_LAYOUT_EXPANDED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return LoudspeakerLayout.UNRECOGNIZED;
  }
}

export function loudspeakerLayoutToJSON(object: LoudspeakerLayout): string {
  switch (object) {
    case LoudspeakerLayout.LOUDSPEAKER_LAYOUT_INVALID:
      return "LOUDSPEAKER_LAYOUT_INVALID";
    case LoudspeakerLayout.LOUDSPEAKER_LAYOUT_MONO:
      return "LOUDSPEAKER_LAYOUT_MONO";
    case LoudspeakerLayout.LOUDSPEAKER_LAYOUT_STEREO:
      return "LOUDSPEAKER_LAYOUT_STEREO";
    case LoudspeakerLayout.LOUDSPEAKER_LAYOUT_5_1_CH:
      return "LOUDSPEAKER_LAYOUT_5_1_CH";
    case LoudspeakerLayout.LOUDSPEAKER_LAYOUT_5_1_2_CH:
      return "LOUDSPEAKER_LAYOUT_5_1_2_CH";
    case LoudspeakerLayout.LOUDSPEAKER_LAYOUT_5_1_4_CH:
      return "LOUDSPEAKER_LAYOUT_5_1_4_CH";
    case LoudspeakerLayout.LOUDSPEAKER_LAYOUT_7_1_CH:
      return "LOUDSPEAKER_LAYOUT_7_1_CH";
    case LoudspeakerLayout.LOUDSPEAKER_LAYOUT_7_1_2_CH:
      return "LOUDSPEAKER_LAYOUT_7_1_2_CH";
    case LoudspeakerLayout.LOUDSPEAKER_LAYOUT_7_1_4_CH:
      return "LOUDSPEAKER_LAYOUT_7_1_4_CH";
    case LoudspeakerLayout.LOUDSPEAKER_LAYOUT_3_1_2_CH:
      return "LOUDSPEAKER_LAYOUT_3_1_2_CH";
    case LoudspeakerLayout.LOUDSPEAKER_LAYOUT_BINAURAL:
      return "LOUDSPEAKER_LAYOUT_BINAURAL";
    case LoudspeakerLayout.LOUDSPEAKER_LAYOUT_RESERVED_10:
      return "LOUDSPEAKER_LAYOUT_RESERVED_10";
    case LoudspeakerLayout.LOUDSPEAKER_LAYOUT_RESERVED_14:
      return "LOUDSPEAKER_LAYOUT_RESERVED_14";
    case LoudspeakerLayout.LOUDSPEAKER_LAYOUT_EXPANDED:
      return "LOUDSPEAKER_LAYOUT_EXPANDED";
    case LoudspeakerLayout.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum ExpandedLoudspeakerLayout {
  EXPANDED_LOUDSPEAKER_LAYOUT_INVALID = 0,
  EXPANDED_LOUDSPEAKER_LAYOUT_LFE = 1,
  EXPANDED_LOUDSPEAKER_LAYOUT_STEREO_S = 2,
  EXPANDED_LOUDSPEAKER_LAYOUT_STEREO_SS = 3,
  EXPANDED_LOUDSPEAKER_LAYOUT_STEREO_RS = 4,
  EXPANDED_LOUDSPEAKER_LAYOUT_STEREO_TF = 5,
  EXPANDED_LOUDSPEAKER_LAYOUT_STEREO_TB = 6,
  EXPANDED_LOUDSPEAKER_LAYOUT_TOP_4_CH = 7,
  EXPANDED_LOUDSPEAKER_LAYOUT_3_0_CH = 8,
  EXPANDED_LOUDSPEAKER_LAYOUT_9_1_6_CH = 9,
  EXPANDED_LOUDSPEAKER_LAYOUT_STEREO_F = 10,
  EXPANDED_LOUDSPEAKER_LAYOUT_STEREO_SI = 11,
  EXPANDED_LOUDSPEAKER_LAYOUT_STEREO_TP_SI = 12,
  EXPANDED_LOUDSPEAKER_LAYOUT_TOP_6_CH = 13,
  EXPANDED_LOUDSPEAKER_LAYOUT_RESERVED_13 = 14,
  EXPANDED_LOUDSPEAKER_LAYOUT_RESERVED_255 = 256,
  UNRECOGNIZED = -1,
}

export function expandedLoudspeakerLayoutFromJSON(object: any): ExpandedLoudspeakerLayout {
  switch (object) {
    case 0:
    case "EXPANDED_LOUDSPEAKER_LAYOUT_INVALID":
      return ExpandedLoudspeakerLayout.EXPANDED_LOUDSPEAKER_LAYOUT_INVALID;
    case 1:
    case "EXPANDED_LOUDSPEAKER_LAYOUT_LFE":
      return ExpandedLoudspeakerLayout.EXPANDED_LOUDSPEAKER_LAYOUT_LFE;
    case 2:
    case "EXPANDED_LOUDSPEAKER_LAYOUT_STEREO_S":
      return ExpandedLoudspeakerLayout.EXPANDED_LOUDSPEAKER_LAYOUT_STEREO_S;
    case 3:
    case "EXPANDED_LOUDSPEAKER_LAYOUT_STEREO_SS":
      return ExpandedLoudspeakerLayout.EXPANDED_LOUDSPEAKER_LAYOUT_STEREO_SS;
    case 4:
    case "EXPANDED_LOUDSPEAKER_LAYOUT_STEREO_RS":
      return ExpandedLoudspeakerLayout.EXPANDED_LOUDSPEAKER_LAYOUT_STEREO_RS;
    case 5:
    case "EXPANDED_LOUDSPEAKER_LAYOUT_STEREO_TF":
      return ExpandedLoudspeakerLayout.EXPANDED_LOUDSPEAKER_LAYOUT_STEREO_TF;
    case 6:
    case "EXPANDED_LOUDSPEAKER_LAYOUT_STEREO_TB":
      return ExpandedLoudspeakerLayout.EXPANDED_LOUDSPEAKER_LAYOUT_STEREO_TB;
    case 7:
    case "EXPANDED_LOUDSPEAKER_LAYOUT_TOP_4_CH":
      return ExpandedLoudspeakerLayout.EXPANDED_LOUDSPEAKER_LAYOUT_TOP_4_CH;
    case 8:
    case "EXPANDED_LOUDSPEAKER_LAYOUT_3_0_CH":
      return ExpandedLoudspeakerLayout.EXPANDED_LOUDSPEAKER_LAYOUT_3_0_CH;
    case 9:
    case "EXPANDED_LOUDSPEAKER_LAYOUT_9_1_6_CH":
      return ExpandedLoudspeakerLayout.EXPANDED_LOUDSPEAKER_LAYOUT_9_1_6_CH;
    case 10:
    case "EXPANDED_LOUDSPEAKER_LAYOUT_STEREO_F":
      return ExpandedLoudspeakerLayout.EXPANDED_LOUDSPEAKER_LAYOUT_STEREO_F;
    case 11:
    case "EXPANDED_LOUDSPEAKER_LAYOUT_STEREO_SI":
      return ExpandedLoudspeakerLayout.EXPANDED_LOUDSPEAKER_LAYOUT_STEREO_SI;
    case 12:
    case "EXPANDED_LOUDSPEAKER_LAYOUT_STEREO_TP_SI":
      return ExpandedLoudspeakerLayout.EXPANDED_LOUDSPEAKER_LAYOUT_STEREO_TP_SI;
    case 13:
    case "EXPANDED_LOUDSPEAKER_LAYOUT_TOP_6_CH":
      return ExpandedLoudspeakerLayout.EXPANDED_LOUDSPEAKER_LAYOUT_TOP_6_CH;
    case 14:
    case "EXPANDED_LOUDSPEAKER_LAYOUT_RESERVED_13":
      return ExpandedLoudspeakerLayout.EXPANDED_LOUDSPEAKER_LAYOUT_RESERVED_13;
    case 256:
    case "EXPANDED_LOUDSPEAKER_LAYOUT_RESERVED_255":
      return ExpandedLoudspeakerLayout.EXPANDED_LOUDSPEAKER_LAYOUT_RESERVED_255;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ExpandedLoudspeakerLayout.UNRECOGNIZED;
  }
}

export function expandedLoudspeakerLayoutToJSON(object: ExpandedLoudspeakerLayout): string {
  switch (object) {
    case ExpandedLoudspeakerLayout.EXPANDED_LOUDSPEAKER_LAYOUT_INVALID:
      return "EXPANDED_LOUDSPEAKER_LAYOUT_INVALID";
    case ExpandedLoudspeakerLayout.EXPANDED_LOUDSPEAKER_LAYOUT_LFE:
      return "EXPANDED_LOUDSPEAKER_LAYOUT_LFE";
    case ExpandedLoudspeakerLayout.EXPANDED_LOUDSPEAKER_LAYOUT_STEREO_S:
      return "EXPANDED_LOUDSPEAKER_LAYOUT_STEREO_S";
    case ExpandedLoudspeakerLayout.EXPANDED_LOUDSPEAKER_LAYOUT_STEREO_SS:
      return "EXPANDED_LOUDSPEAKER_LAYOUT_STEREO_SS";
    case ExpandedLoudspeakerLayout.EXPANDED_LOUDSPEAKER_LAYOUT_STEREO_RS:
      return "EXPANDED_LOUDSPEAKER_LAYOUT_STEREO_RS";
    case ExpandedLoudspeakerLayout.EXPANDED_LOUDSPEAKER_LAYOUT_STEREO_TF:
      return "EXPANDED_LOUDSPEAKER_LAYOUT_STEREO_TF";
    case ExpandedLoudspeakerLayout.EXPANDED_LOUDSPEAKER_LAYOUT_STEREO_TB:
      return "EXPANDED_LOUDSPEAKER_LAYOUT_STEREO_TB";
    case ExpandedLoudspeakerLayout.EXPANDED_LOUDSPEAKER_LAYOUT_TOP_4_CH:
      return "EXPANDED_LOUDSPEAKER_LAYOUT_TOP_4_CH";
    case ExpandedLoudspeakerLayout.EXPANDED_LOUDSPEAKER_LAYOUT_3_0_CH:
      return "EXPANDED_LOUDSPEAKER_LAYOUT_3_0_CH";
    case ExpandedLoudspeakerLayout.EXPANDED_LOUDSPEAKER_LAYOUT_9_1_6_CH:
      return "EXPANDED_LOUDSPEAKER_LAYOUT_9_1_6_CH";
    case ExpandedLoudspeakerLayout.EXPANDED_LOUDSPEAKER_LAYOUT_STEREO_F:
      return "EXPANDED_LOUDSPEAKER_LAYOUT_STEREO_F";
    case ExpandedLoudspeakerLayout.EXPANDED_LOUDSPEAKER_LAYOUT_STEREO_SI:
      return "EXPANDED_LOUDSPEAKER_LAYOUT_STEREO_SI";
    case ExpandedLoudspeakerLayout.EXPANDED_LOUDSPEAKER_LAYOUT_STEREO_TP_SI:
      return "EXPANDED_LOUDSPEAKER_LAYOUT_STEREO_TP_SI";
    case ExpandedLoudspeakerLayout.EXPANDED_LOUDSPEAKER_LAYOUT_TOP_6_CH:
      return "EXPANDED_LOUDSPEAKER_LAYOUT_TOP_6_CH";
    case ExpandedLoudspeakerLayout.EXPANDED_LOUDSPEAKER_LAYOUT_RESERVED_13:
      return "EXPANDED_LOUDSPEAKER_LAYOUT_RESERVED_13";
    case ExpandedLoudspeakerLayout.EXPANDED_LOUDSPEAKER_LAYOUT_RESERVED_255:
      return "EXPANDED_LOUDSPEAKER_LAYOUT_RESERVED_255";
    case ExpandedLoudspeakerLayout.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum AmbisonicsMode {
  AMBISONICS_MODE_INVALID = 0,
  AMBISONICS_MODE_MONO = 1,
  AMBISONICS_MODE_PROJECTION = 2,
  UNRECOGNIZED = -1,
}

export function ambisonicsModeFromJSON(object: any): AmbisonicsMode {
  switch (object) {
    case 0:
    case "AMBISONICS_MODE_INVALID":
      return AmbisonicsMode.AMBISONICS_MODE_INVALID;
    case 1:
    case "AMBISONICS_MODE_MONO":
      return AmbisonicsMode.AMBISONICS_MODE_MONO;
    case 2:
    case "AMBISONICS_MODE_PROJECTION":
      return AmbisonicsMode.AMBISONICS_MODE_PROJECTION;
    case -1:
    case "UNRECOGNIZED":
    default:
      return AmbisonicsMode.UNRECOGNIZED;
  }
}

export function ambisonicsModeToJSON(object: AmbisonicsMode): string {
  switch (object) {
    case AmbisonicsMode.AMBISONICS_MODE_INVALID:
      return "AMBISONICS_MODE_INVALID";
    case AmbisonicsMode.AMBISONICS_MODE_MONO:
      return "AMBISONICS_MODE_MONO";
    case AmbisonicsMode.AMBISONICS_MODE_PROJECTION:
      return "AMBISONICS_MODE_PROJECTION";
    case AmbisonicsMode.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface ParamDefinitionExtension {
  paramDefinitionSize?: number | undefined;
  paramDefinitionBytes?: Uint8Array | undefined;
}

export interface AudioElementParam {
  /** @deprecated */
  deprecatedParamDefinitionType?: number | undefined;
  paramDefinitionType?: ParamDefinitionType | undefined;
  demixingParam?: DemixingParamDefinition | undefined;
  reconGainParam?: ReconGainParamDefinition | undefined;
  paramDefinitionExtension?: ParamDefinitionExtension | undefined;
}

export interface ChannelAudioLayerConfig {
  /** @deprecated */
  deprecatedLoudspeakerLayout?: number | undefined;
  loudspeakerLayout?: LoudspeakerLayout | undefined;
  outputGainIsPresentFlag?: number | undefined;
  reconGainIsPresentFlag?: number | undefined;
  reservedA?: number | undefined;
  substreamCount?: number | undefined;
  coupledSubstreamCount?: number | undefined;
  outputGainFlag?: number | undefined;
  reservedB?: number | undefined;
  outputGain?: number | undefined;
  expandedLoudspeakerLayout?: ExpandedLoudspeakerLayout | undefined;
}

export interface ScalableChannelLayoutConfig {
  numLayers?: number | undefined;
  reserved?: number | undefined;
  channelAudioLayerConfigs: ChannelAudioLayerConfig[];
}

export interface AmbisonicsMonoConfig {
  outputChannelCount?: number | undefined;
  substreamCount?: number | undefined;
  channelMapping: number[];
}

export interface AmbisonicsProjectionConfig {
  outputChannelCount?: number | undefined;
  substreamCount?: number | undefined;
  coupledSubstreamCount?: number | undefined;
  demixingMatrix: number[];
}

export interface AmbisonicsConfig {
  ambisonicsMode?: AmbisonicsMode | undefined;
  ambisonicsMonoConfig?: AmbisonicsMonoConfig | undefined;
  ambisonicsProjectionConfig?: AmbisonicsProjectionConfig | undefined;
}

export interface AudioElementConfigExtension {
  audioElementConfigSize?: number | undefined;
  audioElementConfigBytes?: Uint8Array | undefined;
}

export interface AudioElementObuMetadata {
  audioElementId?: number | undefined;
  audioElementType?: AudioElementType | undefined;
  reserved?: number | undefined;
  codecConfigId?: number | undefined;
  numSubstreams?: number | undefined;
  audioSubstreamIds: number[];
  numParameters?: number | undefined;
  audioElementParams: AudioElementParam[];
  scalableChannelLayoutConfig?: ScalableChannelLayoutConfig | undefined;
  ambisonicsConfig?: AmbisonicsConfig | undefined;
  audioElementConfigExtension?: AudioElementConfigExtension | undefined;
  obuHeader?: ObuHeaderMetadata | undefined;
}

function createBaseParamDefinitionExtension(): ParamDefinitionExtension {
  return { paramDefinitionSize: 0, paramDefinitionBytes: new Uint8Array(0) };
}

export const ParamDefinitionExtension: MessageFns<ParamDefinitionExtension> = {
  encode(message: ParamDefinitionExtension, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.paramDefinitionSize !== undefined && message.paramDefinitionSize !== 0) {
      writer.uint32(8).uint32(message.paramDefinitionSize);
    }
    if (message.paramDefinitionBytes !== undefined && message.paramDefinitionBytes.length !== 0) {
      writer.uint32(18).bytes(message.paramDefinitionBytes);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ParamDefinitionExtension {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseParamDefinitionExtension();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.paramDefinitionSize = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.paramDefinitionBytes = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ParamDefinitionExtension {
    return {
      paramDefinitionSize: isSet(object.paramDefinitionSize) ? globalThis.Number(object.paramDefinitionSize) : 0,
      paramDefinitionBytes: isSet(object.paramDefinitionBytes)
        ? bytesFromBase64(object.paramDefinitionBytes)
        : new Uint8Array(0),
    };
  },

  toJSON(message: ParamDefinitionExtension): unknown {
    const obj: any = {};
    if (message.paramDefinitionSize !== undefined && message.paramDefinitionSize !== 0) {
      obj.paramDefinitionSize = Math.round(message.paramDefinitionSize);
    }
    if (message.paramDefinitionBytes !== undefined && message.paramDefinitionBytes.length !== 0) {
      obj.paramDefinitionBytes = base64FromBytes(message.paramDefinitionBytes);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ParamDefinitionExtension>, I>>(base?: I): ParamDefinitionExtension {
    return ParamDefinitionExtension.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ParamDefinitionExtension>, I>>(object: I): ParamDefinitionExtension {
    const message = createBaseParamDefinitionExtension();
    message.paramDefinitionSize = object.paramDefinitionSize ?? 0;
    message.paramDefinitionBytes = object.paramDefinitionBytes ?? new Uint8Array(0);
    return message;
  },
};

function createBaseAudioElementParam(): AudioElementParam {
  return {
    deprecatedParamDefinitionType: 0,
    paramDefinitionType: 0,
    demixingParam: undefined,
    reconGainParam: undefined,
    paramDefinitionExtension: undefined,
  };
}

export const AudioElementParam: MessageFns<AudioElementParam> = {
  encode(message: AudioElementParam, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.deprecatedParamDefinitionType !== undefined && message.deprecatedParamDefinitionType !== 0) {
      writer.uint32(8).uint32(message.deprecatedParamDefinitionType);
    }
    if (message.paramDefinitionType !== undefined && message.paramDefinitionType !== 0) {
      writer.uint32(40).int32(message.paramDefinitionType);
    }
    if (message.demixingParam !== undefined) {
      DemixingParamDefinition.encode(message.demixingParam, writer.uint32(18).fork()).join();
    }
    if (message.reconGainParam !== undefined) {
      ReconGainParamDefinition.encode(message.reconGainParam, writer.uint32(26).fork()).join();
    }
    if (message.paramDefinitionExtension !== undefined) {
      ParamDefinitionExtension.encode(message.paramDefinitionExtension, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AudioElementParam {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAudioElementParam();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.deprecatedParamDefinitionType = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.paramDefinitionType = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.demixingParam = DemixingParamDefinition.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.reconGainParam = ReconGainParamDefinition.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.paramDefinitionExtension = ParamDefinitionExtension.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AudioElementParam {
    return {
      deprecatedParamDefinitionType: isSet(object.deprecatedParamDefinitionType)
        ? globalThis.Number(object.deprecatedParamDefinitionType)
        : 0,
      paramDefinitionType: isSet(object.paramDefinitionType)
        ? paramDefinitionTypeFromJSON(object.paramDefinitionType)
        : 0,
      demixingParam: isSet(object.demixingParam) ? DemixingParamDefinition.fromJSON(object.demixingParam) : undefined,
      reconGainParam: isSet(object.reconGainParam)
        ? ReconGainParamDefinition.fromJSON(object.reconGainParam)
        : undefined,
      paramDefinitionExtension: isSet(object.paramDefinitionExtension)
        ? ParamDefinitionExtension.fromJSON(object.paramDefinitionExtension)
        : undefined,
    };
  },

  toJSON(message: AudioElementParam): unknown {
    const obj: any = {};
    if (message.deprecatedParamDefinitionType !== undefined && message.deprecatedParamDefinitionType !== 0) {
      obj.deprecatedParamDefinitionType = Math.round(message.deprecatedParamDefinitionType);
    }
    if (message.paramDefinitionType !== undefined && message.paramDefinitionType !== 0) {
      obj.paramDefinitionType = paramDefinitionTypeToJSON(message.paramDefinitionType);
    }
    if (message.demixingParam !== undefined) {
      obj.demixingParam = DemixingParamDefinition.toJSON(message.demixingParam);
    }
    if (message.reconGainParam !== undefined) {
      obj.reconGainParam = ReconGainParamDefinition.toJSON(message.reconGainParam);
    }
    if (message.paramDefinitionExtension !== undefined) {
      obj.paramDefinitionExtension = ParamDefinitionExtension.toJSON(message.paramDefinitionExtension);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AudioElementParam>, I>>(base?: I): AudioElementParam {
    return AudioElementParam.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AudioElementParam>, I>>(object: I): AudioElementParam {
    const message = createBaseAudioElementParam();
    message.deprecatedParamDefinitionType = object.deprecatedParamDefinitionType ?? 0;
    message.paramDefinitionType = object.paramDefinitionType ?? 0;
    message.demixingParam = (object.demixingParam !== undefined && object.demixingParam !== null)
      ? DemixingParamDefinition.fromPartial(object.demixingParam)
      : undefined;
    message.reconGainParam = (object.reconGainParam !== undefined && object.reconGainParam !== null)
      ? ReconGainParamDefinition.fromPartial(object.reconGainParam)
      : undefined;
    message.paramDefinitionExtension =
      (object.paramDefinitionExtension !== undefined && object.paramDefinitionExtension !== null)
        ? ParamDefinitionExtension.fromPartial(object.paramDefinitionExtension)
        : undefined;
    return message;
  },
};

function createBaseChannelAudioLayerConfig(): ChannelAudioLayerConfig {
  return {
    deprecatedLoudspeakerLayout: 0,
    loudspeakerLayout: 0,
    outputGainIsPresentFlag: 0,
    reconGainIsPresentFlag: 0,
    reservedA: 0,
    substreamCount: 0,
    coupledSubstreamCount: 0,
    outputGainFlag: 0,
    reservedB: 0,
    outputGain: 0,
    expandedLoudspeakerLayout: 0,
  };
}

export const ChannelAudioLayerConfig: MessageFns<ChannelAudioLayerConfig> = {
  encode(message: ChannelAudioLayerConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.deprecatedLoudspeakerLayout !== undefined && message.deprecatedLoudspeakerLayout !== 0) {
      writer.uint32(8).uint32(message.deprecatedLoudspeakerLayout);
    }
    if (message.loudspeakerLayout !== undefined && message.loudspeakerLayout !== 0) {
      writer.uint32(80).int32(message.loudspeakerLayout);
    }
    if (message.outputGainIsPresentFlag !== undefined && message.outputGainIsPresentFlag !== 0) {
      writer.uint32(16).uint32(message.outputGainIsPresentFlag);
    }
    if (message.reconGainIsPresentFlag !== undefined && message.reconGainIsPresentFlag !== 0) {
      writer.uint32(24).uint32(message.reconGainIsPresentFlag);
    }
    if (message.reservedA !== undefined && message.reservedA !== 0) {
      writer.uint32(32).uint32(message.reservedA);
    }
    if (message.substreamCount !== undefined && message.substreamCount !== 0) {
      writer.uint32(40).uint32(message.substreamCount);
    }
    if (message.coupledSubstreamCount !== undefined && message.coupledSubstreamCount !== 0) {
      writer.uint32(48).uint32(message.coupledSubstreamCount);
    }
    if (message.outputGainFlag !== undefined && message.outputGainFlag !== 0) {
      writer.uint32(56).uint32(message.outputGainFlag);
    }
    if (message.reservedB !== undefined && message.reservedB !== 0) {
      writer.uint32(64).uint32(message.reservedB);
    }
    if (message.outputGain !== undefined && message.outputGain !== 0) {
      writer.uint32(72).int32(message.outputGain);
    }
    if (message.expandedLoudspeakerLayout !== undefined && message.expandedLoudspeakerLayout !== 0) {
      writer.uint32(88).int32(message.expandedLoudspeakerLayout);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ChannelAudioLayerConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChannelAudioLayerConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.deprecatedLoudspeakerLayout = reader.uint32();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.loudspeakerLayout = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.outputGainIsPresentFlag = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.reconGainIsPresentFlag = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.reservedA = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.substreamCount = reader.uint32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.coupledSubstreamCount = reader.uint32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.outputGainFlag = reader.uint32();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.reservedB = reader.uint32();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.outputGain = reader.int32();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.expandedLoudspeakerLayout = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChannelAudioLayerConfig {
    return {
      deprecatedLoudspeakerLayout: isSet(object.deprecatedLoudspeakerLayout)
        ? globalThis.Number(object.deprecatedLoudspeakerLayout)
        : 0,
      loudspeakerLayout: isSet(object.loudspeakerLayout) ? loudspeakerLayoutFromJSON(object.loudspeakerLayout) : 0,
      outputGainIsPresentFlag: isSet(object.outputGainIsPresentFlag)
        ? globalThis.Number(object.outputGainIsPresentFlag)
        : 0,
      reconGainIsPresentFlag: isSet(object.reconGainIsPresentFlag)
        ? globalThis.Number(object.reconGainIsPresentFlag)
        : 0,
      reservedA: isSet(object.reservedA) ? globalThis.Number(object.reservedA) : 0,
      substreamCount: isSet(object.substreamCount) ? globalThis.Number(object.substreamCount) : 0,
      coupledSubstreamCount: isSet(object.coupledSubstreamCount) ? globalThis.Number(object.coupledSubstreamCount) : 0,
      outputGainFlag: isSet(object.outputGainFlag) ? globalThis.Number(object.outputGainFlag) : 0,
      reservedB: isSet(object.reservedB) ? globalThis.Number(object.reservedB) : 0,
      outputGain: isSet(object.outputGain) ? globalThis.Number(object.outputGain) : 0,
      expandedLoudspeakerLayout: isSet(object.expandedLoudspeakerLayout)
        ? expandedLoudspeakerLayoutFromJSON(object.expandedLoudspeakerLayout)
        : 0,
    };
  },

  toJSON(message: ChannelAudioLayerConfig): unknown {
    const obj: any = {};
    if (message.deprecatedLoudspeakerLayout !== undefined && message.deprecatedLoudspeakerLayout !== 0) {
      obj.deprecatedLoudspeakerLayout = Math.round(message.deprecatedLoudspeakerLayout);
    }
    if (message.loudspeakerLayout !== undefined && message.loudspeakerLayout !== 0) {
      obj.loudspeakerLayout = loudspeakerLayoutToJSON(message.loudspeakerLayout);
    }
    if (message.outputGainIsPresentFlag !== undefined && message.outputGainIsPresentFlag !== 0) {
      obj.outputGainIsPresentFlag = Math.round(message.outputGainIsPresentFlag);
    }
    if (message.reconGainIsPresentFlag !== undefined && message.reconGainIsPresentFlag !== 0) {
      obj.reconGainIsPresentFlag = Math.round(message.reconGainIsPresentFlag);
    }
    if (message.reservedA !== undefined && message.reservedA !== 0) {
      obj.reservedA = Math.round(message.reservedA);
    }
    if (message.substreamCount !== undefined && message.substreamCount !== 0) {
      obj.substreamCount = Math.round(message.substreamCount);
    }
    if (message.coupledSubstreamCount !== undefined && message.coupledSubstreamCount !== 0) {
      obj.coupledSubstreamCount = Math.round(message.coupledSubstreamCount);
    }
    if (message.outputGainFlag !== undefined && message.outputGainFlag !== 0) {
      obj.outputGainFlag = Math.round(message.outputGainFlag);
    }
    if (message.reservedB !== undefined && message.reservedB !== 0) {
      obj.reservedB = Math.round(message.reservedB);
    }
    if (message.outputGain !== undefined && message.outputGain !== 0) {
      obj.outputGain = Math.round(message.outputGain);
    }
    if (message.expandedLoudspeakerLayout !== undefined && message.expandedLoudspeakerLayout !== 0) {
      obj.expandedLoudspeakerLayout = expandedLoudspeakerLayoutToJSON(message.expandedLoudspeakerLayout);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ChannelAudioLayerConfig>, I>>(base?: I): ChannelAudioLayerConfig {
    return ChannelAudioLayerConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ChannelAudioLayerConfig>, I>>(object: I): ChannelAudioLayerConfig {
    const message = createBaseChannelAudioLayerConfig();
    message.deprecatedLoudspeakerLayout = object.deprecatedLoudspeakerLayout ?? 0;
    message.loudspeakerLayout = object.loudspeakerLayout ?? 0;
    message.outputGainIsPresentFlag = object.outputGainIsPresentFlag ?? 0;
    message.reconGainIsPresentFlag = object.reconGainIsPresentFlag ?? 0;
    message.reservedA = object.reservedA ?? 0;
    message.substreamCount = object.substreamCount ?? 0;
    message.coupledSubstreamCount = object.coupledSubstreamCount ?? 0;
    message.outputGainFlag = object.outputGainFlag ?? 0;
    message.reservedB = object.reservedB ?? 0;
    message.outputGain = object.outputGain ?? 0;
    message.expandedLoudspeakerLayout = object.expandedLoudspeakerLayout ?? 0;
    return message;
  },
};

function createBaseScalableChannelLayoutConfig(): ScalableChannelLayoutConfig {
  return { numLayers: 0, reserved: 0, channelAudioLayerConfigs: [] };
}

export const ScalableChannelLayoutConfig: MessageFns<ScalableChannelLayoutConfig> = {
  encode(message: ScalableChannelLayoutConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.numLayers !== undefined && message.numLayers !== 0) {
      writer.uint32(8).uint32(message.numLayers);
    }
    if (message.reserved !== undefined && message.reserved !== 0) {
      writer.uint32(16).uint32(message.reserved);
    }
    for (const v of message.channelAudioLayerConfigs) {
      ChannelAudioLayerConfig.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ScalableChannelLayoutConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseScalableChannelLayoutConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.numLayers = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.reserved = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.channelAudioLayerConfigs.push(ChannelAudioLayerConfig.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ScalableChannelLayoutConfig {
    return {
      numLayers: isSet(object.numLayers) ? globalThis.Number(object.numLayers) : 0,
      reserved: isSet(object.reserved) ? globalThis.Number(object.reserved) : 0,
      channelAudioLayerConfigs: globalThis.Array.isArray(object?.channelAudioLayerConfigs)
        ? object.channelAudioLayerConfigs.map((e: any) => ChannelAudioLayerConfig.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ScalableChannelLayoutConfig): unknown {
    const obj: any = {};
    if (message.numLayers !== undefined && message.numLayers !== 0) {
      obj.numLayers = Math.round(message.numLayers);
    }
    if (message.reserved !== undefined && message.reserved !== 0) {
      obj.reserved = Math.round(message.reserved);
    }
    if (message.channelAudioLayerConfigs?.length) {
      obj.channelAudioLayerConfigs = message.channelAudioLayerConfigs.map((e) => ChannelAudioLayerConfig.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ScalableChannelLayoutConfig>, I>>(base?: I): ScalableChannelLayoutConfig {
    return ScalableChannelLayoutConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ScalableChannelLayoutConfig>, I>>(object: I): ScalableChannelLayoutConfig {
    const message = createBaseScalableChannelLayoutConfig();
    message.numLayers = object.numLayers ?? 0;
    message.reserved = object.reserved ?? 0;
    message.channelAudioLayerConfigs =
      object.channelAudioLayerConfigs?.map((e) => ChannelAudioLayerConfig.fromPartial(e)) || [];
    return message;
  },
};

function createBaseAmbisonicsMonoConfig(): AmbisonicsMonoConfig {
  return { outputChannelCount: 0, substreamCount: 0, channelMapping: [] };
}

export const AmbisonicsMonoConfig: MessageFns<AmbisonicsMonoConfig> = {
  encode(message: AmbisonicsMonoConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.outputChannelCount !== undefined && message.outputChannelCount !== 0) {
      writer.uint32(8).uint32(message.outputChannelCount);
    }
    if (message.substreamCount !== undefined && message.substreamCount !== 0) {
      writer.uint32(16).uint32(message.substreamCount);
    }
    writer.uint32(26).fork();
    for (const v of message.channelMapping) {
      writer.uint32(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AmbisonicsMonoConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAmbisonicsMonoConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.outputChannelCount = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.substreamCount = reader.uint32();
          continue;
        }
        case 3: {
          if (tag === 24) {
            message.channelMapping.push(reader.uint32());

            continue;
          }

          if (tag === 26) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.channelMapping.push(reader.uint32());
            }

            continue;
          }

          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AmbisonicsMonoConfig {
    return {
      outputChannelCount: isSet(object.outputChannelCount) ? globalThis.Number(object.outputChannelCount) : 0,
      substreamCount: isSet(object.substreamCount) ? globalThis.Number(object.substreamCount) : 0,
      channelMapping: globalThis.Array.isArray(object?.channelMapping)
        ? object.channelMapping.map((e: any) => globalThis.Number(e))
        : [],
    };
  },

  toJSON(message: AmbisonicsMonoConfig): unknown {
    const obj: any = {};
    if (message.outputChannelCount !== undefined && message.outputChannelCount !== 0) {
      obj.outputChannelCount = Math.round(message.outputChannelCount);
    }
    if (message.substreamCount !== undefined && message.substreamCount !== 0) {
      obj.substreamCount = Math.round(message.substreamCount);
    }
    if (message.channelMapping?.length) {
      obj.channelMapping = message.channelMapping.map((e) => Math.round(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AmbisonicsMonoConfig>, I>>(base?: I): AmbisonicsMonoConfig {
    return AmbisonicsMonoConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AmbisonicsMonoConfig>, I>>(object: I): AmbisonicsMonoConfig {
    const message = createBaseAmbisonicsMonoConfig();
    message.outputChannelCount = object.outputChannelCount ?? 0;
    message.substreamCount = object.substreamCount ?? 0;
    message.channelMapping = object.channelMapping?.map((e) => e) || [];
    return message;
  },
};

function createBaseAmbisonicsProjectionConfig(): AmbisonicsProjectionConfig {
  return { outputChannelCount: 0, substreamCount: 0, coupledSubstreamCount: 0, demixingMatrix: [] };
}

export const AmbisonicsProjectionConfig: MessageFns<AmbisonicsProjectionConfig> = {
  encode(message: AmbisonicsProjectionConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.outputChannelCount !== undefined && message.outputChannelCount !== 0) {
      writer.uint32(8).uint32(message.outputChannelCount);
    }
    if (message.substreamCount !== undefined && message.substreamCount !== 0) {
      writer.uint32(16).uint32(message.substreamCount);
    }
    if (message.coupledSubstreamCount !== undefined && message.coupledSubstreamCount !== 0) {
      writer.uint32(24).uint32(message.coupledSubstreamCount);
    }
    writer.uint32(34).fork();
    for (const v of message.demixingMatrix) {
      writer.int32(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AmbisonicsProjectionConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAmbisonicsProjectionConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.outputChannelCount = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.substreamCount = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.coupledSubstreamCount = reader.uint32();
          continue;
        }
        case 4: {
          if (tag === 32) {
            message.demixingMatrix.push(reader.int32());

            continue;
          }

          if (tag === 34) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.demixingMatrix.push(reader.int32());
            }

            continue;
          }

          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AmbisonicsProjectionConfig {
    return {
      outputChannelCount: isSet(object.outputChannelCount) ? globalThis.Number(object.outputChannelCount) : 0,
      substreamCount: isSet(object.substreamCount) ? globalThis.Number(object.substreamCount) : 0,
      coupledSubstreamCount: isSet(object.coupledSubstreamCount) ? globalThis.Number(object.coupledSubstreamCount) : 0,
      demixingMatrix: globalThis.Array.isArray(object?.demixingMatrix)
        ? object.demixingMatrix.map((e: any) => globalThis.Number(e))
        : [],
    };
  },

  toJSON(message: AmbisonicsProjectionConfig): unknown {
    const obj: any = {};
    if (message.outputChannelCount !== undefined && message.outputChannelCount !== 0) {
      obj.outputChannelCount = Math.round(message.outputChannelCount);
    }
    if (message.substreamCount !== undefined && message.substreamCount !== 0) {
      obj.substreamCount = Math.round(message.substreamCount);
    }
    if (message.coupledSubstreamCount !== undefined && message.coupledSubstreamCount !== 0) {
      obj.coupledSubstreamCount = Math.round(message.coupledSubstreamCount);
    }
    if (message.demixingMatrix?.length) {
      obj.demixingMatrix = message.demixingMatrix.map((e) => Math.round(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AmbisonicsProjectionConfig>, I>>(base?: I): AmbisonicsProjectionConfig {
    return AmbisonicsProjectionConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AmbisonicsProjectionConfig>, I>>(object: I): AmbisonicsProjectionConfig {
    const message = createBaseAmbisonicsProjectionConfig();
    message.outputChannelCount = object.outputChannelCount ?? 0;
    message.substreamCount = object.substreamCount ?? 0;
    message.coupledSubstreamCount = object.coupledSubstreamCount ?? 0;
    message.demixingMatrix = object.demixingMatrix?.map((e) => e) || [];
    return message;
  },
};

function createBaseAmbisonicsConfig(): AmbisonicsConfig {
  return { ambisonicsMode: 0, ambisonicsMonoConfig: undefined, ambisonicsProjectionConfig: undefined };
}

export const AmbisonicsConfig: MessageFns<AmbisonicsConfig> = {
  encode(message: AmbisonicsConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.ambisonicsMode !== undefined && message.ambisonicsMode !== 0) {
      writer.uint32(8).int32(message.ambisonicsMode);
    }
    if (message.ambisonicsMonoConfig !== undefined) {
      AmbisonicsMonoConfig.encode(message.ambisonicsMonoConfig, writer.uint32(18).fork()).join();
    }
    if (message.ambisonicsProjectionConfig !== undefined) {
      AmbisonicsProjectionConfig.encode(message.ambisonicsProjectionConfig, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AmbisonicsConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAmbisonicsConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.ambisonicsMode = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.ambisonicsMonoConfig = AmbisonicsMonoConfig.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.ambisonicsProjectionConfig = AmbisonicsProjectionConfig.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AmbisonicsConfig {
    return {
      ambisonicsMode: isSet(object.ambisonicsMode) ? ambisonicsModeFromJSON(object.ambisonicsMode) : 0,
      ambisonicsMonoConfig: isSet(object.ambisonicsMonoConfig)
        ? AmbisonicsMonoConfig.fromJSON(object.ambisonicsMonoConfig)
        : undefined,
      ambisonicsProjectionConfig: isSet(object.ambisonicsProjectionConfig)
        ? AmbisonicsProjectionConfig.fromJSON(object.ambisonicsProjectionConfig)
        : undefined,
    };
  },

  toJSON(message: AmbisonicsConfig): unknown {
    const obj: any = {};
    if (message.ambisonicsMode !== undefined && message.ambisonicsMode !== 0) {
      obj.ambisonicsMode = ambisonicsModeToJSON(message.ambisonicsMode);
    }
    if (message.ambisonicsMonoConfig !== undefined) {
      obj.ambisonicsMonoConfig = AmbisonicsMonoConfig.toJSON(message.ambisonicsMonoConfig);
    }
    if (message.ambisonicsProjectionConfig !== undefined) {
      obj.ambisonicsProjectionConfig = AmbisonicsProjectionConfig.toJSON(message.ambisonicsProjectionConfig);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AmbisonicsConfig>, I>>(base?: I): AmbisonicsConfig {
    return AmbisonicsConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AmbisonicsConfig>, I>>(object: I): AmbisonicsConfig {
    const message = createBaseAmbisonicsConfig();
    message.ambisonicsMode = object.ambisonicsMode ?? 0;
    message.ambisonicsMonoConfig = (object.ambisonicsMonoConfig !== undefined && object.ambisonicsMonoConfig !== null)
      ? AmbisonicsMonoConfig.fromPartial(object.ambisonicsMonoConfig)
      : undefined;
    message.ambisonicsProjectionConfig =
      (object.ambisonicsProjectionConfig !== undefined && object.ambisonicsProjectionConfig !== null)
        ? AmbisonicsProjectionConfig.fromPartial(object.ambisonicsProjectionConfig)
        : undefined;
    return message;
  },
};

function createBaseAudioElementConfigExtension(): AudioElementConfigExtension {
  return { audioElementConfigSize: 0, audioElementConfigBytes: new Uint8Array(0) };
}

export const AudioElementConfigExtension: MessageFns<AudioElementConfigExtension> = {
  encode(message: AudioElementConfigExtension, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.audioElementConfigSize !== undefined && message.audioElementConfigSize !== 0) {
      writer.uint32(8).uint32(message.audioElementConfigSize);
    }
    if (message.audioElementConfigBytes !== undefined && message.audioElementConfigBytes.length !== 0) {
      writer.uint32(18).bytes(message.audioElementConfigBytes);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AudioElementConfigExtension {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAudioElementConfigExtension();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.audioElementConfigSize = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.audioElementConfigBytes = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AudioElementConfigExtension {
    return {
      audioElementConfigSize: isSet(object.audioElementConfigSize)
        ? globalThis.Number(object.audioElementConfigSize)
        : 0,
      audioElementConfigBytes: isSet(object.audioElementConfigBytes)
        ? bytesFromBase64(object.audioElementConfigBytes)
        : new Uint8Array(0),
    };
  },

  toJSON(message: AudioElementConfigExtension): unknown {
    const obj: any = {};
    if (message.audioElementConfigSize !== undefined && message.audioElementConfigSize !== 0) {
      obj.audioElementConfigSize = Math.round(message.audioElementConfigSize);
    }
    if (message.audioElementConfigBytes !== undefined && message.audioElementConfigBytes.length !== 0) {
      obj.audioElementConfigBytes = base64FromBytes(message.audioElementConfigBytes);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AudioElementConfigExtension>, I>>(base?: I): AudioElementConfigExtension {
    return AudioElementConfigExtension.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AudioElementConfigExtension>, I>>(object: I): AudioElementConfigExtension {
    const message = createBaseAudioElementConfigExtension();
    message.audioElementConfigSize = object.audioElementConfigSize ?? 0;
    message.audioElementConfigBytes = object.audioElementConfigBytes ?? new Uint8Array(0);
    return message;
  },
};

function createBaseAudioElementObuMetadata(): AudioElementObuMetadata {
  return {
    audioElementId: 0,
    audioElementType: 0,
    reserved: 0,
    codecConfigId: 0,
    numSubstreams: 0,
    audioSubstreamIds: [],
    numParameters: 0,
    audioElementParams: [],
    scalableChannelLayoutConfig: undefined,
    ambisonicsConfig: undefined,
    audioElementConfigExtension: undefined,
    obuHeader: undefined,
  };
}

export const AudioElementObuMetadata: MessageFns<AudioElementObuMetadata> = {
  encode(message: AudioElementObuMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.audioElementId !== undefined && message.audioElementId !== 0) {
      writer.uint32(8).uint32(message.audioElementId);
    }
    if (message.audioElementType !== undefined && message.audioElementType !== 0) {
      writer.uint32(16).int32(message.audioElementType);
    }
    if (message.reserved !== undefined && message.reserved !== 0) {
      writer.uint32(24).uint32(message.reserved);
    }
    if (message.codecConfigId !== undefined && message.codecConfigId !== 0) {
      writer.uint32(32).uint32(message.codecConfigId);
    }
    if (message.numSubstreams !== undefined && message.numSubstreams !== 0) {
      writer.uint32(40).uint32(message.numSubstreams);
    }
    writer.uint32(50).fork();
    for (const v of message.audioSubstreamIds) {
      writer.uint32(v);
    }
    writer.join();
    if (message.numParameters !== undefined && message.numParameters !== 0) {
      writer.uint32(56).uint32(message.numParameters);
    }
    for (const v of message.audioElementParams) {
      AudioElementParam.encode(v!, writer.uint32(66).fork()).join();
    }
    if (message.scalableChannelLayoutConfig !== undefined) {
      ScalableChannelLayoutConfig.encode(message.scalableChannelLayoutConfig, writer.uint32(74).fork()).join();
    }
    if (message.ambisonicsConfig !== undefined) {
      AmbisonicsConfig.encode(message.ambisonicsConfig, writer.uint32(82).fork()).join();
    }
    if (message.audioElementConfigExtension !== undefined) {
      AudioElementConfigExtension.encode(message.audioElementConfigExtension, writer.uint32(90).fork()).join();
    }
    if (message.obuHeader !== undefined) {
      ObuHeaderMetadata.encode(message.obuHeader, writer.uint32(98).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AudioElementObuMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAudioElementObuMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.audioElementId = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.audioElementType = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.reserved = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.codecConfigId = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.numSubstreams = reader.uint32();
          continue;
        }
        case 6: {
          if (tag === 48) {
            message.audioSubstreamIds.push(reader.uint32());

            continue;
          }

          if (tag === 50) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.audioSubstreamIds.push(reader.uint32());
            }

            continue;
          }

          break;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.numParameters = reader.uint32();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.audioElementParams.push(AudioElementParam.decode(reader, reader.uint32()));
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.scalableChannelLayoutConfig = ScalableChannelLayoutConfig.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.ambisonicsConfig = AmbisonicsConfig.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.audioElementConfigExtension = AudioElementConfigExtension.decode(reader, reader.uint32());
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.obuHeader = ObuHeaderMetadata.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AudioElementObuMetadata {
    return {
      audioElementId: isSet(object.audioElementId) ? globalThis.Number(object.audioElementId) : 0,
      audioElementType: isSet(object.audioElementType) ? audioElementTypeFromJSON(object.audioElementType) : 0,
      reserved: isSet(object.reserved) ? globalThis.Number(object.reserved) : 0,
      codecConfigId: isSet(object.codecConfigId) ? globalThis.Number(object.codecConfigId) : 0,
      numSubstreams: isSet(object.numSubstreams) ? globalThis.Number(object.numSubstreams) : 0,
      audioSubstreamIds: globalThis.Array.isArray(object?.audioSubstreamIds)
        ? object.audioSubstreamIds.map((e: any) => globalThis.Number(e))
        : [],
      numParameters: isSet(object.numParameters) ? globalThis.Number(object.numParameters) : 0,
      audioElementParams: globalThis.Array.isArray(object?.audioElementParams)
        ? object.audioElementParams.map((e: any) => AudioElementParam.fromJSON(e))
        : [],
      scalableChannelLayoutConfig: isSet(object.scalableChannelLayoutConfig)
        ? ScalableChannelLayoutConfig.fromJSON(object.scalableChannelLayoutConfig)
        : undefined,
      ambisonicsConfig: isSet(object.ambisonicsConfig) ? AmbisonicsConfig.fromJSON(object.ambisonicsConfig) : undefined,
      audioElementConfigExtension: isSet(object.audioElementConfigExtension)
        ? AudioElementConfigExtension.fromJSON(object.audioElementConfigExtension)
        : undefined,
      obuHeader: isSet(object.obuHeader) ? ObuHeaderMetadata.fromJSON(object.obuHeader) : undefined,
    };
  },

  toJSON(message: AudioElementObuMetadata): unknown {
    const obj: any = {};
    if (message.audioElementId !== undefined && message.audioElementId !== 0) {
      obj.audioElementId = Math.round(message.audioElementId);
    }
    if (message.audioElementType !== undefined && message.audioElementType !== 0) {
      obj.audioElementType = audioElementTypeToJSON(message.audioElementType);
    }
    if (message.reserved !== undefined && message.reserved !== 0) {
      obj.reserved = Math.round(message.reserved);
    }
    if (message.codecConfigId !== undefined && message.codecConfigId !== 0) {
      obj.codecConfigId = Math.round(message.codecConfigId);
    }
    if (message.numSubstreams !== undefined && message.numSubstreams !== 0) {
      obj.numSubstreams = Math.round(message.numSubstreams);
    }
    if (message.audioSubstreamIds?.length) {
      obj.audioSubstreamIds = message.audioSubstreamIds.map((e) => Math.round(e));
    }
    if (message.numParameters !== undefined && message.numParameters !== 0) {
      obj.numParameters = Math.round(message.numParameters);
    }
    if (message.audioElementParams?.length) {
      obj.audioElementParams = message.audioElementParams.map((e) => AudioElementParam.toJSON(e));
    }
    if (message.scalableChannelLayoutConfig !== undefined) {
      obj.scalableChannelLayoutConfig = ScalableChannelLayoutConfig.toJSON(message.scalableChannelLayoutConfig);
    }
    if (message.ambisonicsConfig !== undefined) {
      obj.ambisonicsConfig = AmbisonicsConfig.toJSON(message.ambisonicsConfig);
    }
    if (message.audioElementConfigExtension !== undefined) {
      obj.audioElementConfigExtension = AudioElementConfigExtension.toJSON(message.audioElementConfigExtension);
    }
    if (message.obuHeader !== undefined) {
      obj.obuHeader = ObuHeaderMetadata.toJSON(message.obuHeader);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AudioElementObuMetadata>, I>>(base?: I): AudioElementObuMetadata {
    return AudioElementObuMetadata.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AudioElementObuMetadata>, I>>(object: I): AudioElementObuMetadata {
    const message = createBaseAudioElementObuMetadata();
    message.audioElementId = object.audioElementId ?? 0;
    message.audioElementType = object.audioElementType ?? 0;
    message.reserved = object.reserved ?? 0;
    message.codecConfigId = object.codecConfigId ?? 0;
    message.numSubstreams = object.numSubstreams ?? 0;
    message.audioSubstreamIds = object.audioSubstreamIds?.map((e) => e) || [];
    message.numParameters = object.numParameters ?? 0;
    message.audioElementParams = object.audioElementParams?.map((e) => AudioElementParam.fromPartial(e)) || [];
    message.scalableChannelLayoutConfig =
      (object.scalableChannelLayoutConfig !== undefined && object.scalableChannelLayoutConfig !== null)
        ? ScalableChannelLayoutConfig.fromPartial(object.scalableChannelLayoutConfig)
        : undefined;
    message.ambisonicsConfig = (object.ambisonicsConfig !== undefined && object.ambisonicsConfig !== null)
      ? AmbisonicsConfig.fromPartial(object.ambisonicsConfig)
      : undefined;
    message.audioElementConfigExtension =
      (object.audioElementConfigExtension !== undefined && object.audioElementConfigExtension !== null)
        ? AudioElementConfigExtension.fromPartial(object.audioElementConfigExtension)
        : undefined;
    message.obuHeader = (object.obuHeader !== undefined && object.obuHeader !== null)
      ? ObuHeaderMetadata.fromPartial(object.obuHeader)
      : undefined;
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
