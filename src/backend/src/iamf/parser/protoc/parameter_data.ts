// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.0
//   protoc               v5.29.3
// source: parameter_data.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";

export const protobufPackage = "iamf_tools_cli_proto";

export enum AnimationType {
  ANIMATE_INVALID = 0,
  ANIMATE_STEP = 1,
  ANIMATE_LINEAR = 2,
  ANIMATE_BEZIER = 3,
  UNRECOGNIZED = -1,
}

export function animationTypeFromJSON(object: any): AnimationType {
  switch (object) {
    case 0:
    case "ANIMATE_INVALID":
      return AnimationType.ANIMATE_INVALID;
    case 1:
    case "ANIMATE_STEP":
      return AnimationType.ANIMATE_STEP;
    case 2:
    case "ANIMATE_LINEAR":
      return AnimationType.ANIMATE_LINEAR;
    case 3:
    case "ANIMATE_BEZIER":
      return AnimationType.ANIMATE_BEZIER;
    case -1:
    case "UNRECOGNIZED":
    default:
      return AnimationType.UNRECOGNIZED;
  }
}

export function animationTypeToJSON(object: AnimationType): string {
  switch (object) {
    case AnimationType.ANIMATE_INVALID:
      return "ANIMATE_INVALID";
    case AnimationType.ANIMATE_STEP:
      return "ANIMATE_STEP";
    case AnimationType.ANIMATE_LINEAR:
      return "ANIMATE_LINEAR";
    case AnimationType.ANIMATE_BEZIER:
      return "ANIMATE_BEZIER";
    case AnimationType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum DMixPMode {
  DMIXP_MODE_INVALID = 0,
  /** DMIXP_MODE_1 - (alpha, beta,  gamma, delta, w_idx_offset) */
  DMIXP_MODE_1 = 1,
  /** DMIXP_MODE_2 - (0.707, 0.707, 0.707, 0.707,           -1) */
  DMIXP_MODE_2 = 2,
  /** DMIXP_MODE_3 - (    1, 0.866, 0.866, 0.866,           -1) */
  DMIXP_MODE_3 = 3,
  DMIXP_MODE_RESERVED_A = 4,
  /** DMIXP_MODE_1_N - (    1,     1, 0.707, 0.707,            1) */
  DMIXP_MODE_1_N = 5,
  /** DMIXP_MODE_2_N - (0.707, 0.707, 0.707, 0.707,            1) */
  DMIXP_MODE_2_N = 6,
  /** DMIXP_MODE_3_N - (    1, 0.866, 0.866, 0.866,            1) */
  DMIXP_MODE_3_N = 7,
  DMIXP_MODE_RESERVED_B = 8,
  UNRECOGNIZED = -1,
}

export function dMixPModeFromJSON(object: any): DMixPMode {
  switch (object) {
    case 0:
    case "DMIXP_MODE_INVALID":
      return DMixPMode.DMIXP_MODE_INVALID;
    case 1:
    case "DMIXP_MODE_1":
      return DMixPMode.DMIXP_MODE_1;
    case 2:
    case "DMIXP_MODE_2":
      return DMixPMode.DMIXP_MODE_2;
    case 3:
    case "DMIXP_MODE_3":
      return DMixPMode.DMIXP_MODE_3;
    case 4:
    case "DMIXP_MODE_RESERVED_A":
      return DMixPMode.DMIXP_MODE_RESERVED_A;
    case 5:
    case "DMIXP_MODE_1_N":
      return DMixPMode.DMIXP_MODE_1_N;
    case 6:
    case "DMIXP_MODE_2_N":
      return DMixPMode.DMIXP_MODE_2_N;
    case 7:
    case "DMIXP_MODE_3_N":
      return DMixPMode.DMIXP_MODE_3_N;
    case 8:
    case "DMIXP_MODE_RESERVED_B":
      return DMixPMode.DMIXP_MODE_RESERVED_B;
    case -1:
    case "UNRECOGNIZED":
    default:
      return DMixPMode.UNRECOGNIZED;
  }
}

export function dMixPModeToJSON(object: DMixPMode): string {
  switch (object) {
    case DMixPMode.DMIXP_MODE_INVALID:
      return "DMIXP_MODE_INVALID";
    case DMixPMode.DMIXP_MODE_1:
      return "DMIXP_MODE_1";
    case DMixPMode.DMIXP_MODE_2:
      return "DMIXP_MODE_2";
    case DMixPMode.DMIXP_MODE_3:
      return "DMIXP_MODE_3";
    case DMixPMode.DMIXP_MODE_RESERVED_A:
      return "DMIXP_MODE_RESERVED_A";
    case DMixPMode.DMIXP_MODE_1_N:
      return "DMIXP_MODE_1_N";
    case DMixPMode.DMIXP_MODE_2_N:
      return "DMIXP_MODE_2_N";
    case DMixPMode.DMIXP_MODE_3_N:
      return "DMIXP_MODE_3_N";
    case DMixPMode.DMIXP_MODE_RESERVED_B:
      return "DMIXP_MODE_RESERVED_B";
    case DMixPMode.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Values are represented to align with the IAMF spec.
 *
 * See https://aomediacodec.github.io/iamf/v1.1.0.html#syntax-mix-gain-param for
 * further details.
 *
 * See detailed examples on Q7.8 format below in `AnimationLinearInt16`.
 */
export interface AnimationStepInt16 {
  /** Q7.8. */
  startPointValue?: number | undefined;
}

/**
 * Values are represented to align with the IAMF spec.
 *
 * See https://aomediacodec.github.io/iamf/v1.1.0.html#syntax-mix-gain-param for
 * further details.
 *
 * See detailed examples on Q7.8 format below in `AnimationLinearInt16`.
 */
export interface AnimationLinearInt16 {
  /** Q7.8. */
  startPointValue?:
    | number
    | undefined;
  /** Q7.8. */
  endPointValue?: number | undefined;
}

/**
 * Values are represented to align with the IAMF spec.
 *
 * See https://aomediacodec.github.io/iamf/v1.1.0.html#syntax-mix-gain-param for
 * further details.
 *
 * To convert from dB to Q7.8, multiply by 256. Example:
 *  - For -3 dB, set the proto value to 256 * -3 = -768.
 *  - For +6 dB, set the proto value to 256 * 6 = 1536.
 *
 * To convert from a float in the range [0.0, 1.0] to Q0.8. Multiply by 256 and
 * clamp to the range [0, 255]. Examples:
 *  - For a control point relative time of 0.5, set the proto value to
 *    clam(0.5 * 256, 0, 255) = 128.
 *  - For a control point relative time of 1.0, set the proto value to
 *    clamp(1.0 * 256, 0, 255) = 255.
 */
export interface AnimationBezierInt16 {
  /** Q7.8. */
  startPointValue?:
    | number
    | undefined;
  /** Q7.8. */
  endPointValue?:
    | number
    | undefined;
  /** Q7.8. */
  controlPointValue?:
    | number
    | undefined;
  /** Q0.8. */
  controlPointRelativeTime?: number | undefined;
}

export interface AnimatedParameterDataInt16 {
  step?: AnimationStepInt16 | undefined;
  linear?: AnimationLinearInt16 | undefined;
  bezier?: AnimationBezierInt16 | undefined;
}

export interface MixGainParameterData {
  animationType?: AnimationType | undefined;
  paramData?: AnimatedParameterDataInt16 | undefined;
}

export interface DemixingInfoParameterData {
  dmixpMode?: DMixPMode | undefined;
  reserved?: number | undefined;
}

export interface ReconGains {
  /**
   * Mapping from a bit position to a recon gain value.
   * If recon_gain[j] is defined, then the j-th bit of recon_gain_flags[i]
   * (for the i-th layer) will be set.
   */
  reconGain: { [key: number]: number };
}

export interface ReconGains_ReconGainEntry {
  key: number;
  value: number;
}

export interface ReconGainInfoParameterData {
  /** Length = `num_layers`. */
  reconGainsForLayer: ReconGains[];
}

function createBaseAnimationStepInt16(): AnimationStepInt16 {
  return { startPointValue: 0 };
}

export const AnimationStepInt16: MessageFns<AnimationStepInt16> = {
  encode(message: AnimationStepInt16, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.startPointValue !== undefined && message.startPointValue !== 0) {
      writer.uint32(8).int32(message.startPointValue);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AnimationStepInt16 {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAnimationStepInt16();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.startPointValue = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AnimationStepInt16 {
    return { startPointValue: isSet(object.startPointValue) ? globalThis.Number(object.startPointValue) : 0 };
  },

  toJSON(message: AnimationStepInt16): unknown {
    const obj: any = {};
    if (message.startPointValue !== undefined && message.startPointValue !== 0) {
      obj.startPointValue = Math.round(message.startPointValue);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AnimationStepInt16>, I>>(base?: I): AnimationStepInt16 {
    return AnimationStepInt16.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AnimationStepInt16>, I>>(object: I): AnimationStepInt16 {
    const message = createBaseAnimationStepInt16();
    message.startPointValue = object.startPointValue ?? 0;
    return message;
  },
};

function createBaseAnimationLinearInt16(): AnimationLinearInt16 {
  return { startPointValue: 0, endPointValue: 0 };
}

export const AnimationLinearInt16: MessageFns<AnimationLinearInt16> = {
  encode(message: AnimationLinearInt16, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.startPointValue !== undefined && message.startPointValue !== 0) {
      writer.uint32(8).int32(message.startPointValue);
    }
    if (message.endPointValue !== undefined && message.endPointValue !== 0) {
      writer.uint32(16).int32(message.endPointValue);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AnimationLinearInt16 {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAnimationLinearInt16();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.startPointValue = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.endPointValue = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AnimationLinearInt16 {
    return {
      startPointValue: isSet(object.startPointValue) ? globalThis.Number(object.startPointValue) : 0,
      endPointValue: isSet(object.endPointValue) ? globalThis.Number(object.endPointValue) : 0,
    };
  },

  toJSON(message: AnimationLinearInt16): unknown {
    const obj: any = {};
    if (message.startPointValue !== undefined && message.startPointValue !== 0) {
      obj.startPointValue = Math.round(message.startPointValue);
    }
    if (message.endPointValue !== undefined && message.endPointValue !== 0) {
      obj.endPointValue = Math.round(message.endPointValue);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AnimationLinearInt16>, I>>(base?: I): AnimationLinearInt16 {
    return AnimationLinearInt16.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AnimationLinearInt16>, I>>(object: I): AnimationLinearInt16 {
    const message = createBaseAnimationLinearInt16();
    message.startPointValue = object.startPointValue ?? 0;
    message.endPointValue = object.endPointValue ?? 0;
    return message;
  },
};

function createBaseAnimationBezierInt16(): AnimationBezierInt16 {
  return { startPointValue: 0, endPointValue: 0, controlPointValue: 0, controlPointRelativeTime: 0 };
}

export const AnimationBezierInt16: MessageFns<AnimationBezierInt16> = {
  encode(message: AnimationBezierInt16, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.startPointValue !== undefined && message.startPointValue !== 0) {
      writer.uint32(8).int32(message.startPointValue);
    }
    if (message.endPointValue !== undefined && message.endPointValue !== 0) {
      writer.uint32(16).int32(message.endPointValue);
    }
    if (message.controlPointValue !== undefined && message.controlPointValue !== 0) {
      writer.uint32(24).int32(message.controlPointValue);
    }
    if (message.controlPointRelativeTime !== undefined && message.controlPointRelativeTime !== 0) {
      writer.uint32(32).uint32(message.controlPointRelativeTime);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AnimationBezierInt16 {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAnimationBezierInt16();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.startPointValue = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.endPointValue = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.controlPointValue = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.controlPointRelativeTime = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AnimationBezierInt16 {
    return {
      startPointValue: isSet(object.startPointValue) ? globalThis.Number(object.startPointValue) : 0,
      endPointValue: isSet(object.endPointValue) ? globalThis.Number(object.endPointValue) : 0,
      controlPointValue: isSet(object.controlPointValue) ? globalThis.Number(object.controlPointValue) : 0,
      controlPointRelativeTime: isSet(object.controlPointRelativeTime)
        ? globalThis.Number(object.controlPointRelativeTime)
        : 0,
    };
  },

  toJSON(message: AnimationBezierInt16): unknown {
    const obj: any = {};
    if (message.startPointValue !== undefined && message.startPointValue !== 0) {
      obj.startPointValue = Math.round(message.startPointValue);
    }
    if (message.endPointValue !== undefined && message.endPointValue !== 0) {
      obj.endPointValue = Math.round(message.endPointValue);
    }
    if (message.controlPointValue !== undefined && message.controlPointValue !== 0) {
      obj.controlPointValue = Math.round(message.controlPointValue);
    }
    if (message.controlPointRelativeTime !== undefined && message.controlPointRelativeTime !== 0) {
      obj.controlPointRelativeTime = Math.round(message.controlPointRelativeTime);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AnimationBezierInt16>, I>>(base?: I): AnimationBezierInt16 {
    return AnimationBezierInt16.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AnimationBezierInt16>, I>>(object: I): AnimationBezierInt16 {
    const message = createBaseAnimationBezierInt16();
    message.startPointValue = object.startPointValue ?? 0;
    message.endPointValue = object.endPointValue ?? 0;
    message.controlPointValue = object.controlPointValue ?? 0;
    message.controlPointRelativeTime = object.controlPointRelativeTime ?? 0;
    return message;
  },
};

function createBaseAnimatedParameterDataInt16(): AnimatedParameterDataInt16 {
  return { step: undefined, linear: undefined, bezier: undefined };
}

export const AnimatedParameterDataInt16: MessageFns<AnimatedParameterDataInt16> = {
  encode(message: AnimatedParameterDataInt16, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.step !== undefined) {
      AnimationStepInt16.encode(message.step, writer.uint32(10).fork()).join();
    }
    if (message.linear !== undefined) {
      AnimationLinearInt16.encode(message.linear, writer.uint32(18).fork()).join();
    }
    if (message.bezier !== undefined) {
      AnimationBezierInt16.encode(message.bezier, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AnimatedParameterDataInt16 {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAnimatedParameterDataInt16();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.step = AnimationStepInt16.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.linear = AnimationLinearInt16.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.bezier = AnimationBezierInt16.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AnimatedParameterDataInt16 {
    return {
      step: isSet(object.step) ? AnimationStepInt16.fromJSON(object.step) : undefined,
      linear: isSet(object.linear) ? AnimationLinearInt16.fromJSON(object.linear) : undefined,
      bezier: isSet(object.bezier) ? AnimationBezierInt16.fromJSON(object.bezier) : undefined,
    };
  },

  toJSON(message: AnimatedParameterDataInt16): unknown {
    const obj: any = {};
    if (message.step !== undefined) {
      obj.step = AnimationStepInt16.toJSON(message.step);
    }
    if (message.linear !== undefined) {
      obj.linear = AnimationLinearInt16.toJSON(message.linear);
    }
    if (message.bezier !== undefined) {
      obj.bezier = AnimationBezierInt16.toJSON(message.bezier);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AnimatedParameterDataInt16>, I>>(base?: I): AnimatedParameterDataInt16 {
    return AnimatedParameterDataInt16.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AnimatedParameterDataInt16>, I>>(object: I): AnimatedParameterDataInt16 {
    const message = createBaseAnimatedParameterDataInt16();
    message.step = (object.step !== undefined && object.step !== null)
      ? AnimationStepInt16.fromPartial(object.step)
      : undefined;
    message.linear = (object.linear !== undefined && object.linear !== null)
      ? AnimationLinearInt16.fromPartial(object.linear)
      : undefined;
    message.bezier = (object.bezier !== undefined && object.bezier !== null)
      ? AnimationBezierInt16.fromPartial(object.bezier)
      : undefined;
    return message;
  },
};

function createBaseMixGainParameterData(): MixGainParameterData {
  return { animationType: 0, paramData: undefined };
}

export const MixGainParameterData: MessageFns<MixGainParameterData> = {
  encode(message: MixGainParameterData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.animationType !== undefined && message.animationType !== 0) {
      writer.uint32(8).int32(message.animationType);
    }
    if (message.paramData !== undefined) {
      AnimatedParameterDataInt16.encode(message.paramData, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MixGainParameterData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMixGainParameterData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.animationType = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.paramData = AnimatedParameterDataInt16.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MixGainParameterData {
    return {
      animationType: isSet(object.animationType) ? animationTypeFromJSON(object.animationType) : 0,
      paramData: isSet(object.paramData) ? AnimatedParameterDataInt16.fromJSON(object.paramData) : undefined,
    };
  },

  toJSON(message: MixGainParameterData): unknown {
    const obj: any = {};
    if (message.animationType !== undefined && message.animationType !== 0) {
      obj.animationType = animationTypeToJSON(message.animationType);
    }
    if (message.paramData !== undefined) {
      obj.paramData = AnimatedParameterDataInt16.toJSON(message.paramData);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MixGainParameterData>, I>>(base?: I): MixGainParameterData {
    return MixGainParameterData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MixGainParameterData>, I>>(object: I): MixGainParameterData {
    const message = createBaseMixGainParameterData();
    message.animationType = object.animationType ?? 0;
    message.paramData = (object.paramData !== undefined && object.paramData !== null)
      ? AnimatedParameterDataInt16.fromPartial(object.paramData)
      : undefined;
    return message;
  },
};

function createBaseDemixingInfoParameterData(): DemixingInfoParameterData {
  return { dmixpMode: 0, reserved: 0 };
}

export const DemixingInfoParameterData: MessageFns<DemixingInfoParameterData> = {
  encode(message: DemixingInfoParameterData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.dmixpMode !== undefined && message.dmixpMode !== 0) {
      writer.uint32(8).int32(message.dmixpMode);
    }
    if (message.reserved !== undefined && message.reserved !== 0) {
      writer.uint32(16).uint32(message.reserved);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DemixingInfoParameterData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDemixingInfoParameterData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.dmixpMode = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.reserved = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DemixingInfoParameterData {
    return {
      dmixpMode: isSet(object.dmixpMode) ? dMixPModeFromJSON(object.dmixpMode) : 0,
      reserved: isSet(object.reserved) ? globalThis.Number(object.reserved) : 0,
    };
  },

  toJSON(message: DemixingInfoParameterData): unknown {
    const obj: any = {};
    if (message.dmixpMode !== undefined && message.dmixpMode !== 0) {
      obj.dmixpMode = dMixPModeToJSON(message.dmixpMode);
    }
    if (message.reserved !== undefined && message.reserved !== 0) {
      obj.reserved = Math.round(message.reserved);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DemixingInfoParameterData>, I>>(base?: I): DemixingInfoParameterData {
    return DemixingInfoParameterData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DemixingInfoParameterData>, I>>(object: I): DemixingInfoParameterData {
    const message = createBaseDemixingInfoParameterData();
    message.dmixpMode = object.dmixpMode ?? 0;
    message.reserved = object.reserved ?? 0;
    return message;
  },
};

function createBaseReconGains(): ReconGains {
  return { reconGain: {} };
}

export const ReconGains: MessageFns<ReconGains> = {
  encode(message: ReconGains, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    Object.entries(message.reconGain).forEach(([key, value]) => {
      ReconGains_ReconGainEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReconGains {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReconGains();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2: {
          if (tag !== 18) {
            break;
          }

          const entry2 = ReconGains_ReconGainEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.reconGain[entry2.key] = entry2.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReconGains {
    return {
      reconGain: isObject(object.reconGain)
        ? Object.entries(object.reconGain).reduce<{ [key: number]: number }>((acc, [key, value]) => {
          acc[globalThis.Number(key)] = Number(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: ReconGains): unknown {
    const obj: any = {};
    if (message.reconGain) {
      const entries = Object.entries(message.reconGain);
      if (entries.length > 0) {
        obj.reconGain = {};
        entries.forEach(([k, v]) => {
          obj.reconGain[k] = Math.round(v);
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ReconGains>, I>>(base?: I): ReconGains {
    return ReconGains.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ReconGains>, I>>(object: I): ReconGains {
    const message = createBaseReconGains();
    message.reconGain = Object.entries(object.reconGain ?? {}).reduce<{ [key: number]: number }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[globalThis.Number(key)] = globalThis.Number(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseReconGains_ReconGainEntry(): ReconGains_ReconGainEntry {
  return { key: 0, value: 0 };
}

export const ReconGains_ReconGainEntry: MessageFns<ReconGains_ReconGainEntry> = {
  encode(message: ReconGains_ReconGainEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== 0) {
      writer.uint32(8).uint32(message.key);
    }
    if (message.value !== 0) {
      writer.uint32(16).uint32(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReconGains_ReconGainEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReconGains_ReconGainEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.key = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.value = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReconGains_ReconGainEntry {
    return {
      key: isSet(object.key) ? globalThis.Number(object.key) : 0,
      value: isSet(object.value) ? globalThis.Number(object.value) : 0,
    };
  },

  toJSON(message: ReconGains_ReconGainEntry): unknown {
    const obj: any = {};
    if (message.key !== 0) {
      obj.key = Math.round(message.key);
    }
    if (message.value !== 0) {
      obj.value = Math.round(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ReconGains_ReconGainEntry>, I>>(base?: I): ReconGains_ReconGainEntry {
    return ReconGains_ReconGainEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ReconGains_ReconGainEntry>, I>>(object: I): ReconGains_ReconGainEntry {
    const message = createBaseReconGains_ReconGainEntry();
    message.key = object.key ?? 0;
    message.value = object.value ?? 0;
    return message;
  },
};

function createBaseReconGainInfoParameterData(): ReconGainInfoParameterData {
  return { reconGainsForLayer: [] };
}

export const ReconGainInfoParameterData: MessageFns<ReconGainInfoParameterData> = {
  encode(message: ReconGainInfoParameterData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.reconGainsForLayer) {
      ReconGains.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReconGainInfoParameterData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReconGainInfoParameterData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.reconGainsForLayer.push(ReconGains.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReconGainInfoParameterData {
    return {
      reconGainsForLayer: globalThis.Array.isArray(object?.reconGainsForLayer)
        ? object.reconGainsForLayer.map((e: any) => ReconGains.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ReconGainInfoParameterData): unknown {
    const obj: any = {};
    if (message.reconGainsForLayer?.length) {
      obj.reconGainsForLayer = message.reconGainsForLayer.map((e) => ReconGains.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ReconGainInfoParameterData>, I>>(base?: I): ReconGainInfoParameterData {
    return ReconGainInfoParameterData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ReconGainInfoParameterData>, I>>(object: I): ReconGainInfoParameterData {
    const message = createBaseReconGainInfoParameterData();
    message.reconGainsForLayer = object.reconGainsForLayer?.map((e) => ReconGains.fromPartial(e)) || [];
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
