// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.0
//   protoc               v5.29.3
// source: mix_presentation.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { ObuHeaderMetadata } from "./obu_header";
import { MixGainParamDefinition } from "./param_definitions";

export const protobufPackage = "iamf_tools_cli_proto";

export enum HeadPhonesRenderingMode {
  HEADPHONES_RENDERING_MODE_INVALID = 0,
  HEADPHONES_RENDERING_MODE_STEREO = 1,
  HEADPHONES_RENDERING_MODE_BINAURAL = 2,
  HEADPHONES_RENDERING_MODE_RESERVED_2 = 3,
  HEADPHONES_RENDERING_MODE_RESERVED_3 = 4,
  UNRECOGNIZED = -1,
}

export function headPhonesRenderingModeFromJSON(object: any): HeadPhonesRenderingMode {
  switch (object) {
    case 0:
    case "HEADPHONES_RENDERING_MODE_INVALID":
      return HeadPhonesRenderingMode.HEADPHONES_RENDERING_MODE_INVALID;
    case 1:
    case "HEADPHONES_RENDERING_MODE_STEREO":
      return HeadPhonesRenderingMode.HEADPHONES_RENDERING_MODE_STEREO;
    case 2:
    case "HEADPHONES_RENDERING_MODE_BINAURAL":
      return HeadPhonesRenderingMode.HEADPHONES_RENDERING_MODE_BINAURAL;
    case 3:
    case "HEADPHONES_RENDERING_MODE_RESERVED_2":
      return HeadPhonesRenderingMode.HEADPHONES_RENDERING_MODE_RESERVED_2;
    case 4:
    case "HEADPHONES_RENDERING_MODE_RESERVED_3":
      return HeadPhonesRenderingMode.HEADPHONES_RENDERING_MODE_RESERVED_3;
    case -1:
    case "UNRECOGNIZED":
    default:
      return HeadPhonesRenderingMode.UNRECOGNIZED;
  }
}

export function headPhonesRenderingModeToJSON(object: HeadPhonesRenderingMode): string {
  switch (object) {
    case HeadPhonesRenderingMode.HEADPHONES_RENDERING_MODE_INVALID:
      return "HEADPHONES_RENDERING_MODE_INVALID";
    case HeadPhonesRenderingMode.HEADPHONES_RENDERING_MODE_STEREO:
      return "HEADPHONES_RENDERING_MODE_STEREO";
    case HeadPhonesRenderingMode.HEADPHONES_RENDERING_MODE_BINAURAL:
      return "HEADPHONES_RENDERING_MODE_BINAURAL";
    case HeadPhonesRenderingMode.HEADPHONES_RENDERING_MODE_RESERVED_2:
      return "HEADPHONES_RENDERING_MODE_RESERVED_2";
    case HeadPhonesRenderingMode.HEADPHONES_RENDERING_MODE_RESERVED_3:
      return "HEADPHONES_RENDERING_MODE_RESERVED_3";
    case HeadPhonesRenderingMode.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum SoundSystem {
  SOUND_SYSTEM_INVALID = 0,
  SOUND_SYSTEM_A_0_2_0 = 1,
  SOUND_SYSTEM_B_0_5_0 = 2,
  SOUND_SYSTEM_C_2_5_0 = 3,
  SOUND_SYSTEM_D_4_5_0 = 4,
  SOUND_SYSTEM_E_4_5_1 = 5,
  SOUND_SYSTEM_F_3_7_0 = 6,
  SOUND_SYSTEM_G_4_9_0 = 7,
  SOUND_SYSTEM_H_9_10_3 = 8,
  SOUND_SYSTEM_I_0_7_0 = 9,
  SOUND_SYSTEM_J_4_7_0 = 10,
  SOUND_SYSTEM_10_2_7_0 = 11,
  SOUND_SYSTEM_11_2_3_0 = 12,
  SOUND_SYSTEM_12_0_1_0 = 13,
  SOUND_SYSTEM_13_6_9_0 = 14,
  UNRECOGNIZED = -1,
}

export function soundSystemFromJSON(object: any): SoundSystem {
  switch (object) {
    case 0:
    case "SOUND_SYSTEM_INVALID":
      return SoundSystem.SOUND_SYSTEM_INVALID;
    case 1:
    case "SOUND_SYSTEM_A_0_2_0":
      return SoundSystem.SOUND_SYSTEM_A_0_2_0;
    case 2:
    case "SOUND_SYSTEM_B_0_5_0":
      return SoundSystem.SOUND_SYSTEM_B_0_5_0;
    case 3:
    case "SOUND_SYSTEM_C_2_5_0":
      return SoundSystem.SOUND_SYSTEM_C_2_5_0;
    case 4:
    case "SOUND_SYSTEM_D_4_5_0":
      return SoundSystem.SOUND_SYSTEM_D_4_5_0;
    case 5:
    case "SOUND_SYSTEM_E_4_5_1":
      return SoundSystem.SOUND_SYSTEM_E_4_5_1;
    case 6:
    case "SOUND_SYSTEM_F_3_7_0":
      return SoundSystem.SOUND_SYSTEM_F_3_7_0;
    case 7:
    case "SOUND_SYSTEM_G_4_9_0":
      return SoundSystem.SOUND_SYSTEM_G_4_9_0;
    case 8:
    case "SOUND_SYSTEM_H_9_10_3":
      return SoundSystem.SOUND_SYSTEM_H_9_10_3;
    case 9:
    case "SOUND_SYSTEM_I_0_7_0":
      return SoundSystem.SOUND_SYSTEM_I_0_7_0;
    case 10:
    case "SOUND_SYSTEM_J_4_7_0":
      return SoundSystem.SOUND_SYSTEM_J_4_7_0;
    case 11:
    case "SOUND_SYSTEM_10_2_7_0":
      return SoundSystem.SOUND_SYSTEM_10_2_7_0;
    case 12:
    case "SOUND_SYSTEM_11_2_3_0":
      return SoundSystem.SOUND_SYSTEM_11_2_3_0;
    case 13:
    case "SOUND_SYSTEM_12_0_1_0":
      return SoundSystem.SOUND_SYSTEM_12_0_1_0;
    case 14:
    case "SOUND_SYSTEM_13_6_9_0":
      return SoundSystem.SOUND_SYSTEM_13_6_9_0;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SoundSystem.UNRECOGNIZED;
  }
}

export function soundSystemToJSON(object: SoundSystem): string {
  switch (object) {
    case SoundSystem.SOUND_SYSTEM_INVALID:
      return "SOUND_SYSTEM_INVALID";
    case SoundSystem.SOUND_SYSTEM_A_0_2_0:
      return "SOUND_SYSTEM_A_0_2_0";
    case SoundSystem.SOUND_SYSTEM_B_0_5_0:
      return "SOUND_SYSTEM_B_0_5_0";
    case SoundSystem.SOUND_SYSTEM_C_2_5_0:
      return "SOUND_SYSTEM_C_2_5_0";
    case SoundSystem.SOUND_SYSTEM_D_4_5_0:
      return "SOUND_SYSTEM_D_4_5_0";
    case SoundSystem.SOUND_SYSTEM_E_4_5_1:
      return "SOUND_SYSTEM_E_4_5_1";
    case SoundSystem.SOUND_SYSTEM_F_3_7_0:
      return "SOUND_SYSTEM_F_3_7_0";
    case SoundSystem.SOUND_SYSTEM_G_4_9_0:
      return "SOUND_SYSTEM_G_4_9_0";
    case SoundSystem.SOUND_SYSTEM_H_9_10_3:
      return "SOUND_SYSTEM_H_9_10_3";
    case SoundSystem.SOUND_SYSTEM_I_0_7_0:
      return "SOUND_SYSTEM_I_0_7_0";
    case SoundSystem.SOUND_SYSTEM_J_4_7_0:
      return "SOUND_SYSTEM_J_4_7_0";
    case SoundSystem.SOUND_SYSTEM_10_2_7_0:
      return "SOUND_SYSTEM_10_2_7_0";
    case SoundSystem.SOUND_SYSTEM_11_2_3_0:
      return "SOUND_SYSTEM_11_2_3_0";
    case SoundSystem.SOUND_SYSTEM_12_0_1_0:
      return "SOUND_SYSTEM_12_0_1_0";
    case SoundSystem.SOUND_SYSTEM_13_6_9_0:
      return "SOUND_SYSTEM_13_6_9_0";
    case SoundSystem.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum LayoutType {
  LAYOUT_TYPE_INVALID = 0,
  LAYOUT_TYPE_RESERVED_0 = 1,
  LAYOUT_TYPE_RESERVED_1 = 2,
  LAYOUT_TYPE_LOUDSPEAKERS_SS_CONVENTION = 3,
  LAYOUT_TYPE_BINAURAL = 4,
  UNRECOGNIZED = -1,
}

export function layoutTypeFromJSON(object: any): LayoutType {
  switch (object) {
    case 0:
    case "LAYOUT_TYPE_INVALID":
      return LayoutType.LAYOUT_TYPE_INVALID;
    case 1:
    case "LAYOUT_TYPE_RESERVED_0":
      return LayoutType.LAYOUT_TYPE_RESERVED_0;
    case 2:
    case "LAYOUT_TYPE_RESERVED_1":
      return LayoutType.LAYOUT_TYPE_RESERVED_1;
    case 3:
    case "LAYOUT_TYPE_LOUDSPEAKERS_SS_CONVENTION":
      return LayoutType.LAYOUT_TYPE_LOUDSPEAKERS_SS_CONVENTION;
    case 4:
    case "LAYOUT_TYPE_BINAURAL":
      return LayoutType.LAYOUT_TYPE_BINAURAL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return LayoutType.UNRECOGNIZED;
  }
}

export function layoutTypeToJSON(object: LayoutType): string {
  switch (object) {
    case LayoutType.LAYOUT_TYPE_INVALID:
      return "LAYOUT_TYPE_INVALID";
    case LayoutType.LAYOUT_TYPE_RESERVED_0:
      return "LAYOUT_TYPE_RESERVED_0";
    case LayoutType.LAYOUT_TYPE_RESERVED_1:
      return "LAYOUT_TYPE_RESERVED_1";
    case LayoutType.LAYOUT_TYPE_LOUDSPEAKERS_SS_CONVENTION:
      return "LAYOUT_TYPE_LOUDSPEAKERS_SS_CONVENTION";
    case LayoutType.LAYOUT_TYPE_BINAURAL:
      return "LAYOUT_TYPE_BINAURAL";
    case LayoutType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum AnchorType {
  ANCHOR_TYPE_INVALID = 0,
  ANCHOR_TYPE_UNKNOWN = 1,
  ANCHOR_TYPE_DIALOGUE = 2,
  ANCHOR_TYPE_ALBUM = 3,
  UNRECOGNIZED = -1,
}

export function anchorTypeFromJSON(object: any): AnchorType {
  switch (object) {
    case 0:
    case "ANCHOR_TYPE_INVALID":
      return AnchorType.ANCHOR_TYPE_INVALID;
    case 1:
    case "ANCHOR_TYPE_UNKNOWN":
      return AnchorType.ANCHOR_TYPE_UNKNOWN;
    case 2:
    case "ANCHOR_TYPE_DIALOGUE":
      return AnchorType.ANCHOR_TYPE_DIALOGUE;
    case 3:
    case "ANCHOR_TYPE_ALBUM":
      return AnchorType.ANCHOR_TYPE_ALBUM;
    case -1:
    case "UNRECOGNIZED":
    default:
      return AnchorType.UNRECOGNIZED;
  }
}

export function anchorTypeToJSON(object: AnchorType): string {
  switch (object) {
    case AnchorType.ANCHOR_TYPE_INVALID:
      return "ANCHOR_TYPE_INVALID";
    case AnchorType.ANCHOR_TYPE_UNKNOWN:
      return "ANCHOR_TYPE_UNKNOWN";
    case AnchorType.ANCHOR_TYPE_DIALOGUE:
      return "ANCHOR_TYPE_DIALOGUE";
    case AnchorType.ANCHOR_TYPE_ALBUM:
      return "ANCHOR_TYPE_ALBUM";
    case AnchorType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum LoudnessInfoTypeBitMask {
  LOUDNESS_INFO_TYPE_INVALID = 0,
  LOUDNESS_INFO_TYPE_TRUE_PEAK = 1,
  LOUDNESS_INFO_TYPE_ANCHORED_LOUDNESS = 2,
  LOUDNESS_INFO_TYPE_RESERVED_4 = 4,
  LOUDNESS_INFO_TYPE_RESERVED_8 = 8,
  LOUDNESS_INFO_TYPE_RESERVED_16 = 16,
  LOUDNESS_INFO_TYPE_RESERVED_32 = 32,
  LOUDNESS_INFO_TYPE_RESERVED_64 = 64,
  LOUDNESS_INFO_TYPE_RESERVED_128 = 128,
  UNRECOGNIZED = -1,
}

export function loudnessInfoTypeBitMaskFromJSON(object: any): LoudnessInfoTypeBitMask {
  switch (object) {
    case 0:
    case "LOUDNESS_INFO_TYPE_INVALID":
      return LoudnessInfoTypeBitMask.LOUDNESS_INFO_TYPE_INVALID;
    case 1:
    case "LOUDNESS_INFO_TYPE_TRUE_PEAK":
      return LoudnessInfoTypeBitMask.LOUDNESS_INFO_TYPE_TRUE_PEAK;
    case 2:
    case "LOUDNESS_INFO_TYPE_ANCHORED_LOUDNESS":
      return LoudnessInfoTypeBitMask.LOUDNESS_INFO_TYPE_ANCHORED_LOUDNESS;
    case 4:
    case "LOUDNESS_INFO_TYPE_RESERVED_4":
      return LoudnessInfoTypeBitMask.LOUDNESS_INFO_TYPE_RESERVED_4;
    case 8:
    case "LOUDNESS_INFO_TYPE_RESERVED_8":
      return LoudnessInfoTypeBitMask.LOUDNESS_INFO_TYPE_RESERVED_8;
    case 16:
    case "LOUDNESS_INFO_TYPE_RESERVED_16":
      return LoudnessInfoTypeBitMask.LOUDNESS_INFO_TYPE_RESERVED_16;
    case 32:
    case "LOUDNESS_INFO_TYPE_RESERVED_32":
      return LoudnessInfoTypeBitMask.LOUDNESS_INFO_TYPE_RESERVED_32;
    case 64:
    case "LOUDNESS_INFO_TYPE_RESERVED_64":
      return LoudnessInfoTypeBitMask.LOUDNESS_INFO_TYPE_RESERVED_64;
    case 128:
    case "LOUDNESS_INFO_TYPE_RESERVED_128":
      return LoudnessInfoTypeBitMask.LOUDNESS_INFO_TYPE_RESERVED_128;
    case -1:
    case "UNRECOGNIZED":
    default:
      return LoudnessInfoTypeBitMask.UNRECOGNIZED;
  }
}

export function loudnessInfoTypeBitMaskToJSON(object: LoudnessInfoTypeBitMask): string {
  switch (object) {
    case LoudnessInfoTypeBitMask.LOUDNESS_INFO_TYPE_INVALID:
      return "LOUDNESS_INFO_TYPE_INVALID";
    case LoudnessInfoTypeBitMask.LOUDNESS_INFO_TYPE_TRUE_PEAK:
      return "LOUDNESS_INFO_TYPE_TRUE_PEAK";
    case LoudnessInfoTypeBitMask.LOUDNESS_INFO_TYPE_ANCHORED_LOUDNESS:
      return "LOUDNESS_INFO_TYPE_ANCHORED_LOUDNESS";
    case LoudnessInfoTypeBitMask.LOUDNESS_INFO_TYPE_RESERVED_4:
      return "LOUDNESS_INFO_TYPE_RESERVED_4";
    case LoudnessInfoTypeBitMask.LOUDNESS_INFO_TYPE_RESERVED_8:
      return "LOUDNESS_INFO_TYPE_RESERVED_8";
    case LoudnessInfoTypeBitMask.LOUDNESS_INFO_TYPE_RESERVED_16:
      return "LOUDNESS_INFO_TYPE_RESERVED_16";
    case LoudnessInfoTypeBitMask.LOUDNESS_INFO_TYPE_RESERVED_32:
      return "LOUDNESS_INFO_TYPE_RESERVED_32";
    case LoudnessInfoTypeBitMask.LOUDNESS_INFO_TYPE_RESERVED_64:
      return "LOUDNESS_INFO_TYPE_RESERVED_64";
    case LoudnessInfoTypeBitMask.LOUDNESS_INFO_TYPE_RESERVED_128:
      return "LOUDNESS_INFO_TYPE_RESERVED_128";
    case LoudnessInfoTypeBitMask.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** @deprecated */
export interface MixPresentationAnnotations {
  mixPresentationFriendlyLabel?: string | undefined;
}

/** @deprecated */
export interface MixPresentationElementAnnotations {
  audioElementFriendlyLabel?: string | undefined;
}

/** @deprecated */
export interface ElementMixConfig {
  mixGain?: MixGainParamDefinition | undefined;
}

export interface RenderingConfig {
  headphonesRenderingMode?: HeadPhonesRenderingMode | undefined;
  reserved?: number | undefined;
  renderingConfigExtensionSize?: number | undefined;
  renderingConfigExtensionBytes?: Uint8Array | undefined;
}

export interface SubMixAudioElement {
  audioElementId?:
    | number
    | undefined;
  /**
   * Superseded by `localized_element_annotations`.
   *
   * @deprecated
   */
  mixPresentationElementAnnotationsArray: MixPresentationElementAnnotations[];
  /** Length should be equal to `count_label` in the OBU. */
  localizedElementAnnotations: string[];
  renderingConfig?:
    | RenderingConfig
    | undefined;
  /**
   * Superseded by `element_mix_gain`.
   *
   * @deprecated
   */
  elementMixConfig?: ElementMixConfig | undefined;
  elementMixGain?: MixGainParamDefinition | undefined;
}

/** @deprecated */
export interface OutputMixConfig {
  outputMixGain?: MixGainParamDefinition | undefined;
}

export interface LoudspeakersSsConventionLayout {
  soundSystem?: SoundSystem | undefined;
  reserved?: number | undefined;
}

export interface LoudspeakersReservedOrBinauralLayout {
  reserved?: number | undefined;
}

export interface Layout {
  layoutType?: LayoutType | undefined;
  ssLayout?: LoudspeakersSsConventionLayout | undefined;
  reservedOrBinauralLayout?: LoudspeakersReservedOrBinauralLayout | undefined;
}

/**
 * Values are represented to align with the IAMF spec.
 *
 * See
 * https://aomediacodec.github.io/iamf/v1.1.0.html#obu-mixpresentation-loudness
 * for further details.
 *
 * See detailed examples on Q7.8 format below in `LoudnessInfo`.
 */
export interface AnchorElement {
  anchorElement?:
    | AnchorType
    | undefined;
  /** Q7.8. */
  anchoredLoudness?: number | undefined;
}

export interface AnchoredLoudness {
  /**
   * `num_anchored_loudness` is ignored. The value in the bitstream is inferred
   * based on the number of `anchor_elements`.
   *
   * @deprecated
   */
  numAnchoredLoudness?: number | undefined;
  anchorElements: AnchorElement[];
}

/**
 * Values are represented to align with the IAMF spec.
 *
 * See
 * https://aomediacodec.github.io/iamf/v1.1.0.html#obu-mixpresentation-loudness
 * for further details.
 *
 * To convert from dB to Q7.8, multiply by 256. Example:
 *  - For -3 dB, set the proto value to 256 * -3 = -768.
 *  - For +6 dB, set the proto value to 256 * 6 = 1536.
 */
export interface LoudnessInfo {
  /** @deprecated */
  deprecatedInfoType?: number | undefined;
  infoTypeBitMasks: LoudnessInfoTypeBitMask[];
  /** Q7.8. */
  integratedLoudness?:
    | number
    | undefined;
  /** Q7.8. */
  digitalPeak?:
    | number
    | undefined;
  /** Q7.8. */
  truePeak?: number | undefined;
  anchoredLoudness?: AnchoredLoudness | undefined;
  infoTypeSize?: number | undefined;
  infoTypeBytes?: Uint8Array | undefined;
}

export interface MixPresentationLayout {
  loudnessLayout?: Layout | undefined;
  loudness?: LoudnessInfo | undefined;
}

export interface MixPresentationSubMix {
  /**
   * `num_audio_elements` is ignored. The value in the bitstream is inferred
   * based on the number of `audio_elements`.
   *
   * @deprecated
   */
  numAudioElements?: number | undefined;
  audioElements: SubMixAudioElement[];
  /**
   * Superseded by `output_mix_gain`.
   *
   * @deprecated
   */
  outputMixConfig?: OutputMixConfig | undefined;
  outputMixGain?:
    | MixGainParamDefinition
    | undefined;
  /**
   * `num_layouts` is ignored. The value in the bitstream is inferred
   * based on the number of `layouts`.
   *
   * @deprecated
   */
  numLayouts?: number | undefined;
  layouts: MixPresentationLayout[];
}

export interface MixPresentationTag {
  tagName?: string | undefined;
  tagValue?: string | undefined;
}

export interface MixPresentationTags {
  /**
   * `num_tags` is ignored. The value in the bitstream is inferred based on the
   * number of tags.
   *
   * @deprecated
   */
  numTags?: number | undefined;
  tags: MixPresentationTag[];
}

export interface MixPresentationObuMetadata {
  mixPresentationId?: number | undefined;
  countLabel?:
    | number
    | undefined;
  /**
   * Superseded by `annotations_language`.
   *
   * @deprecated
   */
  languageLabels: string[];
  /** Length should be equal to `count_label`. */
  annotationsLanguage: string[];
  /**
   * Superseded by `localized_presentation_annotations`.
   *
   * @deprecated
   */
  mixPresentationAnnotationsArray: MixPresentationAnnotations[];
  /** Length should be equal to `count_label`. */
  localizedPresentationAnnotations: string[];
  /**
   * `num_sub_mixes` is ignored. The value in the bitstream is inferred
   * based on the number of `sub_mixes`.
   *
   * @deprecated
   */
  numSubMixes?: number | undefined;
  subMixes: MixPresentationSubMix[];
  /**
   * When false [default]: The encoder will ignore the below
   *                      `mix_presentation_tags`. Beware that other features
   *                      may still result in additional non-user specified
   *                      tags. To stricly encode a file without any tags, set
   *                      both `include_mix_presentation_tags` and
   *                      `EncoderControlMetadata.add_build_information_tag`
   *                      fields to false.
   * When true: The encoder will use the `mix_presentation_tags` field.
   */
  includeMixPresentationTags?: boolean | undefined;
  mixPresentationTags?: MixPresentationTags | undefined;
  obuHeader?: ObuHeaderMetadata | undefined;
}

function createBaseMixPresentationAnnotations(): MixPresentationAnnotations {
  return { mixPresentationFriendlyLabel: "" };
}

export const MixPresentationAnnotations: MessageFns<MixPresentationAnnotations> = {
  encode(message: MixPresentationAnnotations, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.mixPresentationFriendlyLabel !== undefined && message.mixPresentationFriendlyLabel !== "") {
      writer.uint32(10).string(message.mixPresentationFriendlyLabel);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MixPresentationAnnotations {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMixPresentationAnnotations();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.mixPresentationFriendlyLabel = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MixPresentationAnnotations {
    return {
      mixPresentationFriendlyLabel: isSet(object.mixPresentationFriendlyLabel)
        ? globalThis.String(object.mixPresentationFriendlyLabel)
        : "",
    };
  },

  toJSON(message: MixPresentationAnnotations): unknown {
    const obj: any = {};
    if (message.mixPresentationFriendlyLabel !== undefined && message.mixPresentationFriendlyLabel !== "") {
      obj.mixPresentationFriendlyLabel = message.mixPresentationFriendlyLabel;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MixPresentationAnnotations>, I>>(base?: I): MixPresentationAnnotations {
    return MixPresentationAnnotations.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MixPresentationAnnotations>, I>>(object: I): MixPresentationAnnotations {
    const message = createBaseMixPresentationAnnotations();
    message.mixPresentationFriendlyLabel = object.mixPresentationFriendlyLabel ?? "";
    return message;
  },
};

function createBaseMixPresentationElementAnnotations(): MixPresentationElementAnnotations {
  return { audioElementFriendlyLabel: "" };
}

export const MixPresentationElementAnnotations: MessageFns<MixPresentationElementAnnotations> = {
  encode(message: MixPresentationElementAnnotations, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.audioElementFriendlyLabel !== undefined && message.audioElementFriendlyLabel !== "") {
      writer.uint32(10).string(message.audioElementFriendlyLabel);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MixPresentationElementAnnotations {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMixPresentationElementAnnotations();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.audioElementFriendlyLabel = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MixPresentationElementAnnotations {
    return {
      audioElementFriendlyLabel: isSet(object.audioElementFriendlyLabel)
        ? globalThis.String(object.audioElementFriendlyLabel)
        : "",
    };
  },

  toJSON(message: MixPresentationElementAnnotations): unknown {
    const obj: any = {};
    if (message.audioElementFriendlyLabel !== undefined && message.audioElementFriendlyLabel !== "") {
      obj.audioElementFriendlyLabel = message.audioElementFriendlyLabel;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MixPresentationElementAnnotations>, I>>(
    base?: I,
  ): MixPresentationElementAnnotations {
    return MixPresentationElementAnnotations.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MixPresentationElementAnnotations>, I>>(
    object: I,
  ): MixPresentationElementAnnotations {
    const message = createBaseMixPresentationElementAnnotations();
    message.audioElementFriendlyLabel = object.audioElementFriendlyLabel ?? "";
    return message;
  },
};

function createBaseElementMixConfig(): ElementMixConfig {
  return { mixGain: undefined };
}

export const ElementMixConfig: MessageFns<ElementMixConfig> = {
  encode(message: ElementMixConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.mixGain !== undefined) {
      MixGainParamDefinition.encode(message.mixGain, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ElementMixConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseElementMixConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.mixGain = MixGainParamDefinition.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ElementMixConfig {
    return { mixGain: isSet(object.mixGain) ? MixGainParamDefinition.fromJSON(object.mixGain) : undefined };
  },

  toJSON(message: ElementMixConfig): unknown {
    const obj: any = {};
    if (message.mixGain !== undefined) {
      obj.mixGain = MixGainParamDefinition.toJSON(message.mixGain);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ElementMixConfig>, I>>(base?: I): ElementMixConfig {
    return ElementMixConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ElementMixConfig>, I>>(object: I): ElementMixConfig {
    const message = createBaseElementMixConfig();
    message.mixGain = (object.mixGain !== undefined && object.mixGain !== null)
      ? MixGainParamDefinition.fromPartial(object.mixGain)
      : undefined;
    return message;
  },
};

function createBaseRenderingConfig(): RenderingConfig {
  return {
    headphonesRenderingMode: 0,
    reserved: 0,
    renderingConfigExtensionSize: 0,
    renderingConfigExtensionBytes: new Uint8Array(0),
  };
}

export const RenderingConfig: MessageFns<RenderingConfig> = {
  encode(message: RenderingConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.headphonesRenderingMode !== undefined && message.headphonesRenderingMode !== 0) {
      writer.uint32(8).int32(message.headphonesRenderingMode);
    }
    if (message.reserved !== undefined && message.reserved !== 0) {
      writer.uint32(16).uint32(message.reserved);
    }
    if (message.renderingConfigExtensionSize !== undefined && message.renderingConfigExtensionSize !== 0) {
      writer.uint32(24).uint32(message.renderingConfigExtensionSize);
    }
    if (message.renderingConfigExtensionBytes !== undefined && message.renderingConfigExtensionBytes.length !== 0) {
      writer.uint32(34).bytes(message.renderingConfigExtensionBytes);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RenderingConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRenderingConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.headphonesRenderingMode = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.reserved = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.renderingConfigExtensionSize = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.renderingConfigExtensionBytes = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RenderingConfig {
    return {
      headphonesRenderingMode: isSet(object.headphonesRenderingMode)
        ? headPhonesRenderingModeFromJSON(object.headphonesRenderingMode)
        : 0,
      reserved: isSet(object.reserved) ? globalThis.Number(object.reserved) : 0,
      renderingConfigExtensionSize: isSet(object.renderingConfigExtensionSize)
        ? globalThis.Number(object.renderingConfigExtensionSize)
        : 0,
      renderingConfigExtensionBytes: isSet(object.renderingConfigExtensionBytes)
        ? bytesFromBase64(object.renderingConfigExtensionBytes)
        : new Uint8Array(0),
    };
  },

  toJSON(message: RenderingConfig): unknown {
    const obj: any = {};
    if (message.headphonesRenderingMode !== undefined && message.headphonesRenderingMode !== 0) {
      obj.headphonesRenderingMode = headPhonesRenderingModeToJSON(message.headphonesRenderingMode);
    }
    if (message.reserved !== undefined && message.reserved !== 0) {
      obj.reserved = Math.round(message.reserved);
    }
    if (message.renderingConfigExtensionSize !== undefined && message.renderingConfigExtensionSize !== 0) {
      obj.renderingConfigExtensionSize = Math.round(message.renderingConfigExtensionSize);
    }
    if (message.renderingConfigExtensionBytes !== undefined && message.renderingConfigExtensionBytes.length !== 0) {
      obj.renderingConfigExtensionBytes = base64FromBytes(message.renderingConfigExtensionBytes);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RenderingConfig>, I>>(base?: I): RenderingConfig {
    return RenderingConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RenderingConfig>, I>>(object: I): RenderingConfig {
    const message = createBaseRenderingConfig();
    message.headphonesRenderingMode = object.headphonesRenderingMode ?? 0;
    message.reserved = object.reserved ?? 0;
    message.renderingConfigExtensionSize = object.renderingConfigExtensionSize ?? 0;
    message.renderingConfigExtensionBytes = object.renderingConfigExtensionBytes ?? new Uint8Array(0);
    return message;
  },
};

function createBaseSubMixAudioElement(): SubMixAudioElement {
  return {
    audioElementId: 0,
    mixPresentationElementAnnotationsArray: [],
    localizedElementAnnotations: [],
    renderingConfig: undefined,
    elementMixConfig: undefined,
    elementMixGain: undefined,
  };
}

export const SubMixAudioElement: MessageFns<SubMixAudioElement> = {
  encode(message: SubMixAudioElement, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.audioElementId !== undefined && message.audioElementId !== 0) {
      writer.uint32(8).uint32(message.audioElementId);
    }
    for (const v of message.mixPresentationElementAnnotationsArray) {
      MixPresentationElementAnnotations.encode(v!, writer.uint32(34).fork()).join();
    }
    for (const v of message.localizedElementAnnotations) {
      writer.uint32(50).string(v!);
    }
    if (message.renderingConfig !== undefined) {
      RenderingConfig.encode(message.renderingConfig, writer.uint32(42).fork()).join();
    }
    if (message.elementMixConfig !== undefined) {
      ElementMixConfig.encode(message.elementMixConfig, writer.uint32(26).fork()).join();
    }
    if (message.elementMixGain !== undefined) {
      MixGainParamDefinition.encode(message.elementMixGain, writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SubMixAudioElement {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubMixAudioElement();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.audioElementId = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.mixPresentationElementAnnotationsArray.push(
            MixPresentationElementAnnotations.decode(reader, reader.uint32()),
          );
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.localizedElementAnnotations.push(reader.string());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.renderingConfig = RenderingConfig.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.elementMixConfig = ElementMixConfig.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.elementMixGain = MixGainParamDefinition.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SubMixAudioElement {
    return {
      audioElementId: isSet(object.audioElementId) ? globalThis.Number(object.audioElementId) : 0,
      mixPresentationElementAnnotationsArray: globalThis.Array.isArray(object?.mixPresentationElementAnnotationsArray)
        ? object.mixPresentationElementAnnotationsArray.map((e: any) => MixPresentationElementAnnotations.fromJSON(e))
        : [],
      localizedElementAnnotations: globalThis.Array.isArray(object?.localizedElementAnnotations)
        ? object.localizedElementAnnotations.map((e: any) => globalThis.String(e))
        : [],
      renderingConfig: isSet(object.renderingConfig) ? RenderingConfig.fromJSON(object.renderingConfig) : undefined,
      elementMixConfig: isSet(object.elementMixConfig) ? ElementMixConfig.fromJSON(object.elementMixConfig) : undefined,
      elementMixGain: isSet(object.elementMixGain) ? MixGainParamDefinition.fromJSON(object.elementMixGain) : undefined,
    };
  },

  toJSON(message: SubMixAudioElement): unknown {
    const obj: any = {};
    if (message.audioElementId !== undefined && message.audioElementId !== 0) {
      obj.audioElementId = Math.round(message.audioElementId);
    }
    if (message.mixPresentationElementAnnotationsArray?.length) {
      obj.mixPresentationElementAnnotationsArray = message.mixPresentationElementAnnotationsArray.map((e) =>
        MixPresentationElementAnnotations.toJSON(e)
      );
    }
    if (message.localizedElementAnnotations?.length) {
      obj.localizedElementAnnotations = message.localizedElementAnnotations;
    }
    if (message.renderingConfig !== undefined) {
      obj.renderingConfig = RenderingConfig.toJSON(message.renderingConfig);
    }
    if (message.elementMixConfig !== undefined) {
      obj.elementMixConfig = ElementMixConfig.toJSON(message.elementMixConfig);
    }
    if (message.elementMixGain !== undefined) {
      obj.elementMixGain = MixGainParamDefinition.toJSON(message.elementMixGain);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SubMixAudioElement>, I>>(base?: I): SubMixAudioElement {
    return SubMixAudioElement.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SubMixAudioElement>, I>>(object: I): SubMixAudioElement {
    const message = createBaseSubMixAudioElement();
    message.audioElementId = object.audioElementId ?? 0;
    message.mixPresentationElementAnnotationsArray =
      object.mixPresentationElementAnnotationsArray?.map((e) => MixPresentationElementAnnotations.fromPartial(e)) || [];
    message.localizedElementAnnotations = object.localizedElementAnnotations?.map((e) => e) || [];
    message.renderingConfig = (object.renderingConfig !== undefined && object.renderingConfig !== null)
      ? RenderingConfig.fromPartial(object.renderingConfig)
      : undefined;
    message.elementMixConfig = (object.elementMixConfig !== undefined && object.elementMixConfig !== null)
      ? ElementMixConfig.fromPartial(object.elementMixConfig)
      : undefined;
    message.elementMixGain = (object.elementMixGain !== undefined && object.elementMixGain !== null)
      ? MixGainParamDefinition.fromPartial(object.elementMixGain)
      : undefined;
    return message;
  },
};

function createBaseOutputMixConfig(): OutputMixConfig {
  return { outputMixGain: undefined };
}

export const OutputMixConfig: MessageFns<OutputMixConfig> = {
  encode(message: OutputMixConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.outputMixGain !== undefined) {
      MixGainParamDefinition.encode(message.outputMixGain, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OutputMixConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOutputMixConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.outputMixGain = MixGainParamDefinition.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OutputMixConfig {
    return {
      outputMixGain: isSet(object.outputMixGain) ? MixGainParamDefinition.fromJSON(object.outputMixGain) : undefined,
    };
  },

  toJSON(message: OutputMixConfig): unknown {
    const obj: any = {};
    if (message.outputMixGain !== undefined) {
      obj.outputMixGain = MixGainParamDefinition.toJSON(message.outputMixGain);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OutputMixConfig>, I>>(base?: I): OutputMixConfig {
    return OutputMixConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OutputMixConfig>, I>>(object: I): OutputMixConfig {
    const message = createBaseOutputMixConfig();
    message.outputMixGain = (object.outputMixGain !== undefined && object.outputMixGain !== null)
      ? MixGainParamDefinition.fromPartial(object.outputMixGain)
      : undefined;
    return message;
  },
};

function createBaseLoudspeakersSsConventionLayout(): LoudspeakersSsConventionLayout {
  return { soundSystem: 0, reserved: 0 };
}

export const LoudspeakersSsConventionLayout: MessageFns<LoudspeakersSsConventionLayout> = {
  encode(message: LoudspeakersSsConventionLayout, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.soundSystem !== undefined && message.soundSystem !== 0) {
      writer.uint32(8).int32(message.soundSystem);
    }
    if (message.reserved !== undefined && message.reserved !== 0) {
      writer.uint32(16).uint32(message.reserved);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LoudspeakersSsConventionLayout {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLoudspeakersSsConventionLayout();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.soundSystem = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.reserved = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LoudspeakersSsConventionLayout {
    return {
      soundSystem: isSet(object.soundSystem) ? soundSystemFromJSON(object.soundSystem) : 0,
      reserved: isSet(object.reserved) ? globalThis.Number(object.reserved) : 0,
    };
  },

  toJSON(message: LoudspeakersSsConventionLayout): unknown {
    const obj: any = {};
    if (message.soundSystem !== undefined && message.soundSystem !== 0) {
      obj.soundSystem = soundSystemToJSON(message.soundSystem);
    }
    if (message.reserved !== undefined && message.reserved !== 0) {
      obj.reserved = Math.round(message.reserved);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LoudspeakersSsConventionLayout>, I>>(base?: I): LoudspeakersSsConventionLayout {
    return LoudspeakersSsConventionLayout.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LoudspeakersSsConventionLayout>, I>>(
    object: I,
  ): LoudspeakersSsConventionLayout {
    const message = createBaseLoudspeakersSsConventionLayout();
    message.soundSystem = object.soundSystem ?? 0;
    message.reserved = object.reserved ?? 0;
    return message;
  },
};

function createBaseLoudspeakersReservedOrBinauralLayout(): LoudspeakersReservedOrBinauralLayout {
  return { reserved: 0 };
}

export const LoudspeakersReservedOrBinauralLayout: MessageFns<LoudspeakersReservedOrBinauralLayout> = {
  encode(message: LoudspeakersReservedOrBinauralLayout, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.reserved !== undefined && message.reserved !== 0) {
      writer.uint32(8).uint32(message.reserved);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LoudspeakersReservedOrBinauralLayout {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLoudspeakersReservedOrBinauralLayout();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.reserved = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LoudspeakersReservedOrBinauralLayout {
    return { reserved: isSet(object.reserved) ? globalThis.Number(object.reserved) : 0 };
  },

  toJSON(message: LoudspeakersReservedOrBinauralLayout): unknown {
    const obj: any = {};
    if (message.reserved !== undefined && message.reserved !== 0) {
      obj.reserved = Math.round(message.reserved);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LoudspeakersReservedOrBinauralLayout>, I>>(
    base?: I,
  ): LoudspeakersReservedOrBinauralLayout {
    return LoudspeakersReservedOrBinauralLayout.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LoudspeakersReservedOrBinauralLayout>, I>>(
    object: I,
  ): LoudspeakersReservedOrBinauralLayout {
    const message = createBaseLoudspeakersReservedOrBinauralLayout();
    message.reserved = object.reserved ?? 0;
    return message;
  },
};

function createBaseLayout(): Layout {
  return { layoutType: 0, ssLayout: undefined, reservedOrBinauralLayout: undefined };
}

export const Layout: MessageFns<Layout> = {
  encode(message: Layout, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.layoutType !== undefined && message.layoutType !== 0) {
      writer.uint32(8).int32(message.layoutType);
    }
    if (message.ssLayout !== undefined) {
      LoudspeakersSsConventionLayout.encode(message.ssLayout, writer.uint32(26).fork()).join();
    }
    if (message.reservedOrBinauralLayout !== undefined) {
      LoudspeakersReservedOrBinauralLayout.encode(message.reservedOrBinauralLayout, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Layout {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLayout();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.layoutType = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.ssLayout = LoudspeakersSsConventionLayout.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.reservedOrBinauralLayout = LoudspeakersReservedOrBinauralLayout.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Layout {
    return {
      layoutType: isSet(object.layoutType) ? layoutTypeFromJSON(object.layoutType) : 0,
      ssLayout: isSet(object.ssLayout) ? LoudspeakersSsConventionLayout.fromJSON(object.ssLayout) : undefined,
      reservedOrBinauralLayout: isSet(object.reservedOrBinauralLayout)
        ? LoudspeakersReservedOrBinauralLayout.fromJSON(object.reservedOrBinauralLayout)
        : undefined,
    };
  },

  toJSON(message: Layout): unknown {
    const obj: any = {};
    if (message.layoutType !== undefined && message.layoutType !== 0) {
      obj.layoutType = layoutTypeToJSON(message.layoutType);
    }
    if (message.ssLayout !== undefined) {
      obj.ssLayout = LoudspeakersSsConventionLayout.toJSON(message.ssLayout);
    }
    if (message.reservedOrBinauralLayout !== undefined) {
      obj.reservedOrBinauralLayout = LoudspeakersReservedOrBinauralLayout.toJSON(message.reservedOrBinauralLayout);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Layout>, I>>(base?: I): Layout {
    return Layout.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Layout>, I>>(object: I): Layout {
    const message = createBaseLayout();
    message.layoutType = object.layoutType ?? 0;
    message.ssLayout = (object.ssLayout !== undefined && object.ssLayout !== null)
      ? LoudspeakersSsConventionLayout.fromPartial(object.ssLayout)
      : undefined;
    message.reservedOrBinauralLayout =
      (object.reservedOrBinauralLayout !== undefined && object.reservedOrBinauralLayout !== null)
        ? LoudspeakersReservedOrBinauralLayout.fromPartial(object.reservedOrBinauralLayout)
        : undefined;
    return message;
  },
};

function createBaseAnchorElement(): AnchorElement {
  return { anchorElement: 0, anchoredLoudness: 0 };
}

export const AnchorElement: MessageFns<AnchorElement> = {
  encode(message: AnchorElement, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.anchorElement !== undefined && message.anchorElement !== 0) {
      writer.uint32(8).int32(message.anchorElement);
    }
    if (message.anchoredLoudness !== undefined && message.anchoredLoudness !== 0) {
      writer.uint32(16).int32(message.anchoredLoudness);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AnchorElement {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAnchorElement();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.anchorElement = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.anchoredLoudness = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AnchorElement {
    return {
      anchorElement: isSet(object.anchorElement) ? anchorTypeFromJSON(object.anchorElement) : 0,
      anchoredLoudness: isSet(object.anchoredLoudness) ? globalThis.Number(object.anchoredLoudness) : 0,
    };
  },

  toJSON(message: AnchorElement): unknown {
    const obj: any = {};
    if (message.anchorElement !== undefined && message.anchorElement !== 0) {
      obj.anchorElement = anchorTypeToJSON(message.anchorElement);
    }
    if (message.anchoredLoudness !== undefined && message.anchoredLoudness !== 0) {
      obj.anchoredLoudness = Math.round(message.anchoredLoudness);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AnchorElement>, I>>(base?: I): AnchorElement {
    return AnchorElement.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AnchorElement>, I>>(object: I): AnchorElement {
    const message = createBaseAnchorElement();
    message.anchorElement = object.anchorElement ?? 0;
    message.anchoredLoudness = object.anchoredLoudness ?? 0;
    return message;
  },
};

function createBaseAnchoredLoudness(): AnchoredLoudness {
  return { numAnchoredLoudness: 0, anchorElements: [] };
}

export const AnchoredLoudness: MessageFns<AnchoredLoudness> = {
  encode(message: AnchoredLoudness, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.numAnchoredLoudness !== undefined && message.numAnchoredLoudness !== 0) {
      writer.uint32(8).uint32(message.numAnchoredLoudness);
    }
    for (const v of message.anchorElements) {
      AnchorElement.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AnchoredLoudness {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAnchoredLoudness();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.numAnchoredLoudness = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.anchorElements.push(AnchorElement.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AnchoredLoudness {
    return {
      numAnchoredLoudness: isSet(object.numAnchoredLoudness) ? globalThis.Number(object.numAnchoredLoudness) : 0,
      anchorElements: globalThis.Array.isArray(object?.anchorElements)
        ? object.anchorElements.map((e: any) => AnchorElement.fromJSON(e))
        : [],
    };
  },

  toJSON(message: AnchoredLoudness): unknown {
    const obj: any = {};
    if (message.numAnchoredLoudness !== undefined && message.numAnchoredLoudness !== 0) {
      obj.numAnchoredLoudness = Math.round(message.numAnchoredLoudness);
    }
    if (message.anchorElements?.length) {
      obj.anchorElements = message.anchorElements.map((e) => AnchorElement.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AnchoredLoudness>, I>>(base?: I): AnchoredLoudness {
    return AnchoredLoudness.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AnchoredLoudness>, I>>(object: I): AnchoredLoudness {
    const message = createBaseAnchoredLoudness();
    message.numAnchoredLoudness = object.numAnchoredLoudness ?? 0;
    message.anchorElements = object.anchorElements?.map((e) => AnchorElement.fromPartial(e)) || [];
    return message;
  },
};

function createBaseLoudnessInfo(): LoudnessInfo {
  return {
    deprecatedInfoType: 0,
    infoTypeBitMasks: [],
    integratedLoudness: 0,
    digitalPeak: 0,
    truePeak: 0,
    anchoredLoudness: undefined,
    infoTypeSize: 0,
    infoTypeBytes: new Uint8Array(0),
  };
}

export const LoudnessInfo: MessageFns<LoudnessInfo> = {
  encode(message: LoudnessInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.deprecatedInfoType !== undefined && message.deprecatedInfoType !== 0) {
      writer.uint32(8).uint32(message.deprecatedInfoType);
    }
    writer.uint32(66).fork();
    for (const v of message.infoTypeBitMasks) {
      writer.int32(v);
    }
    writer.join();
    if (message.integratedLoudness !== undefined && message.integratedLoudness !== 0) {
      writer.uint32(16).int32(message.integratedLoudness);
    }
    if (message.digitalPeak !== undefined && message.digitalPeak !== 0) {
      writer.uint32(24).int32(message.digitalPeak);
    }
    if (message.truePeak !== undefined && message.truePeak !== 0) {
      writer.uint32(32).int32(message.truePeak);
    }
    if (message.anchoredLoudness !== undefined) {
      AnchoredLoudness.encode(message.anchoredLoudness, writer.uint32(42).fork()).join();
    }
    if (message.infoTypeSize !== undefined && message.infoTypeSize !== 0) {
      writer.uint32(48).uint32(message.infoTypeSize);
    }
    if (message.infoTypeBytes !== undefined && message.infoTypeBytes.length !== 0) {
      writer.uint32(58).bytes(message.infoTypeBytes);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LoudnessInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLoudnessInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.deprecatedInfoType = reader.uint32();
          continue;
        }
        case 8: {
          if (tag === 64) {
            message.infoTypeBitMasks.push(reader.int32() as any);

            continue;
          }

          if (tag === 66) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.infoTypeBitMasks.push(reader.int32() as any);
            }

            continue;
          }

          break;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.integratedLoudness = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.digitalPeak = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.truePeak = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.anchoredLoudness = AnchoredLoudness.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.infoTypeSize = reader.uint32();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.infoTypeBytes = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LoudnessInfo {
    return {
      deprecatedInfoType: isSet(object.deprecatedInfoType) ? globalThis.Number(object.deprecatedInfoType) : 0,
      infoTypeBitMasks: globalThis.Array.isArray(object?.infoTypeBitMasks)
        ? object.infoTypeBitMasks.map((e: any) => loudnessInfoTypeBitMaskFromJSON(e))
        : [],
      integratedLoudness: isSet(object.integratedLoudness) ? globalThis.Number(object.integratedLoudness) : 0,
      digitalPeak: isSet(object.digitalPeak) ? globalThis.Number(object.digitalPeak) : 0,
      truePeak: isSet(object.truePeak) ? globalThis.Number(object.truePeak) : 0,
      anchoredLoudness: isSet(object.anchoredLoudness) ? AnchoredLoudness.fromJSON(object.anchoredLoudness) : undefined,
      infoTypeSize: isSet(object.infoTypeSize) ? globalThis.Number(object.infoTypeSize) : 0,
      infoTypeBytes: isSet(object.infoTypeBytes) ? bytesFromBase64(object.infoTypeBytes) : new Uint8Array(0),
    };
  },

  toJSON(message: LoudnessInfo): unknown {
    const obj: any = {};
    if (message.deprecatedInfoType !== undefined && message.deprecatedInfoType !== 0) {
      obj.deprecatedInfoType = Math.round(message.deprecatedInfoType);
    }
    if (message.infoTypeBitMasks?.length) {
      obj.infoTypeBitMasks = message.infoTypeBitMasks.map((e) => loudnessInfoTypeBitMaskToJSON(e));
    }
    if (message.integratedLoudness !== undefined && message.integratedLoudness !== 0) {
      obj.integratedLoudness = Math.round(message.integratedLoudness);
    }
    if (message.digitalPeak !== undefined && message.digitalPeak !== 0) {
      obj.digitalPeak = Math.round(message.digitalPeak);
    }
    if (message.truePeak !== undefined && message.truePeak !== 0) {
      obj.truePeak = Math.round(message.truePeak);
    }
    if (message.anchoredLoudness !== undefined) {
      obj.anchoredLoudness = AnchoredLoudness.toJSON(message.anchoredLoudness);
    }
    if (message.infoTypeSize !== undefined && message.infoTypeSize !== 0) {
      obj.infoTypeSize = Math.round(message.infoTypeSize);
    }
    if (message.infoTypeBytes !== undefined && message.infoTypeBytes.length !== 0) {
      obj.infoTypeBytes = base64FromBytes(message.infoTypeBytes);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LoudnessInfo>, I>>(base?: I): LoudnessInfo {
    return LoudnessInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LoudnessInfo>, I>>(object: I): LoudnessInfo {
    const message = createBaseLoudnessInfo();
    message.deprecatedInfoType = object.deprecatedInfoType ?? 0;
    message.infoTypeBitMasks = object.infoTypeBitMasks?.map((e) => e) || [];
    message.integratedLoudness = object.integratedLoudness ?? 0;
    message.digitalPeak = object.digitalPeak ?? 0;
    message.truePeak = object.truePeak ?? 0;
    message.anchoredLoudness = (object.anchoredLoudness !== undefined && object.anchoredLoudness !== null)
      ? AnchoredLoudness.fromPartial(object.anchoredLoudness)
      : undefined;
    message.infoTypeSize = object.infoTypeSize ?? 0;
    message.infoTypeBytes = object.infoTypeBytes ?? new Uint8Array(0);
    return message;
  },
};

function createBaseMixPresentationLayout(): MixPresentationLayout {
  return { loudnessLayout: undefined, loudness: undefined };
}

export const MixPresentationLayout: MessageFns<MixPresentationLayout> = {
  encode(message: MixPresentationLayout, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.loudnessLayout !== undefined) {
      Layout.encode(message.loudnessLayout, writer.uint32(10).fork()).join();
    }
    if (message.loudness !== undefined) {
      LoudnessInfo.encode(message.loudness, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MixPresentationLayout {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMixPresentationLayout();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.loudnessLayout = Layout.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.loudness = LoudnessInfo.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MixPresentationLayout {
    return {
      loudnessLayout: isSet(object.loudnessLayout) ? Layout.fromJSON(object.loudnessLayout) : undefined,
      loudness: isSet(object.loudness) ? LoudnessInfo.fromJSON(object.loudness) : undefined,
    };
  },

  toJSON(message: MixPresentationLayout): unknown {
    const obj: any = {};
    if (message.loudnessLayout !== undefined) {
      obj.loudnessLayout = Layout.toJSON(message.loudnessLayout);
    }
    if (message.loudness !== undefined) {
      obj.loudness = LoudnessInfo.toJSON(message.loudness);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MixPresentationLayout>, I>>(base?: I): MixPresentationLayout {
    return MixPresentationLayout.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MixPresentationLayout>, I>>(object: I): MixPresentationLayout {
    const message = createBaseMixPresentationLayout();
    message.loudnessLayout = (object.loudnessLayout !== undefined && object.loudnessLayout !== null)
      ? Layout.fromPartial(object.loudnessLayout)
      : undefined;
    message.loudness = (object.loudness !== undefined && object.loudness !== null)
      ? LoudnessInfo.fromPartial(object.loudness)
      : undefined;
    return message;
  },
};

function createBaseMixPresentationSubMix(): MixPresentationSubMix {
  return {
    numAudioElements: 0,
    audioElements: [],
    outputMixConfig: undefined,
    outputMixGain: undefined,
    numLayouts: 0,
    layouts: [],
  };
}

export const MixPresentationSubMix: MessageFns<MixPresentationSubMix> = {
  encode(message: MixPresentationSubMix, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.numAudioElements !== undefined && message.numAudioElements !== 0) {
      writer.uint32(8).uint32(message.numAudioElements);
    }
    for (const v of message.audioElements) {
      SubMixAudioElement.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.outputMixConfig !== undefined) {
      OutputMixConfig.encode(message.outputMixConfig, writer.uint32(26).fork()).join();
    }
    if (message.outputMixGain !== undefined) {
      MixGainParamDefinition.encode(message.outputMixGain, writer.uint32(50).fork()).join();
    }
    if (message.numLayouts !== undefined && message.numLayouts !== 0) {
      writer.uint32(32).uint32(message.numLayouts);
    }
    for (const v of message.layouts) {
      MixPresentationLayout.encode(v!, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MixPresentationSubMix {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMixPresentationSubMix();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.numAudioElements = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.audioElements.push(SubMixAudioElement.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.outputMixConfig = OutputMixConfig.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.outputMixGain = MixGainParamDefinition.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.numLayouts = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.layouts.push(MixPresentationLayout.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MixPresentationSubMix {
    return {
      numAudioElements: isSet(object.numAudioElements) ? globalThis.Number(object.numAudioElements) : 0,
      audioElements: globalThis.Array.isArray(object?.audioElements)
        ? object.audioElements.map((e: any) => SubMixAudioElement.fromJSON(e))
        : [],
      outputMixConfig: isSet(object.outputMixConfig) ? OutputMixConfig.fromJSON(object.outputMixConfig) : undefined,
      outputMixGain: isSet(object.outputMixGain) ? MixGainParamDefinition.fromJSON(object.outputMixGain) : undefined,
      numLayouts: isSet(object.numLayouts) ? globalThis.Number(object.numLayouts) : 0,
      layouts: globalThis.Array.isArray(object?.layouts)
        ? object.layouts.map((e: any) => MixPresentationLayout.fromJSON(e))
        : [],
    };
  },

  toJSON(message: MixPresentationSubMix): unknown {
    const obj: any = {};
    if (message.numAudioElements !== undefined && message.numAudioElements !== 0) {
      obj.numAudioElements = Math.round(message.numAudioElements);
    }
    if (message.audioElements?.length) {
      obj.audioElements = message.audioElements.map((e) => SubMixAudioElement.toJSON(e));
    }
    if (message.outputMixConfig !== undefined) {
      obj.outputMixConfig = OutputMixConfig.toJSON(message.outputMixConfig);
    }
    if (message.outputMixGain !== undefined) {
      obj.outputMixGain = MixGainParamDefinition.toJSON(message.outputMixGain);
    }
    if (message.numLayouts !== undefined && message.numLayouts !== 0) {
      obj.numLayouts = Math.round(message.numLayouts);
    }
    if (message.layouts?.length) {
      obj.layouts = message.layouts.map((e) => MixPresentationLayout.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MixPresentationSubMix>, I>>(base?: I): MixPresentationSubMix {
    return MixPresentationSubMix.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MixPresentationSubMix>, I>>(object: I): MixPresentationSubMix {
    const message = createBaseMixPresentationSubMix();
    message.numAudioElements = object.numAudioElements ?? 0;
    message.audioElements = object.audioElements?.map((e) => SubMixAudioElement.fromPartial(e)) || [];
    message.outputMixConfig = (object.outputMixConfig !== undefined && object.outputMixConfig !== null)
      ? OutputMixConfig.fromPartial(object.outputMixConfig)
      : undefined;
    message.outputMixGain = (object.outputMixGain !== undefined && object.outputMixGain !== null)
      ? MixGainParamDefinition.fromPartial(object.outputMixGain)
      : undefined;
    message.numLayouts = object.numLayouts ?? 0;
    message.layouts = object.layouts?.map((e) => MixPresentationLayout.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMixPresentationTag(): MixPresentationTag {
  return { tagName: "", tagValue: "" };
}

export const MixPresentationTag: MessageFns<MixPresentationTag> = {
  encode(message: MixPresentationTag, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.tagName !== undefined && message.tagName !== "") {
      writer.uint32(10).string(message.tagName);
    }
    if (message.tagValue !== undefined && message.tagValue !== "") {
      writer.uint32(18).string(message.tagValue);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MixPresentationTag {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMixPresentationTag();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.tagName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.tagValue = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MixPresentationTag {
    return {
      tagName: isSet(object.tagName) ? globalThis.String(object.tagName) : "",
      tagValue: isSet(object.tagValue) ? globalThis.String(object.tagValue) : "",
    };
  },

  toJSON(message: MixPresentationTag): unknown {
    const obj: any = {};
    if (message.tagName !== undefined && message.tagName !== "") {
      obj.tagName = message.tagName;
    }
    if (message.tagValue !== undefined && message.tagValue !== "") {
      obj.tagValue = message.tagValue;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MixPresentationTag>, I>>(base?: I): MixPresentationTag {
    return MixPresentationTag.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MixPresentationTag>, I>>(object: I): MixPresentationTag {
    const message = createBaseMixPresentationTag();
    message.tagName = object.tagName ?? "";
    message.tagValue = object.tagValue ?? "";
    return message;
  },
};

function createBaseMixPresentationTags(): MixPresentationTags {
  return { numTags: 0, tags: [] };
}

export const MixPresentationTags: MessageFns<MixPresentationTags> = {
  encode(message: MixPresentationTags, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.numTags !== undefined && message.numTags !== 0) {
      writer.uint32(8).uint32(message.numTags);
    }
    for (const v of message.tags) {
      MixPresentationTag.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MixPresentationTags {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMixPresentationTags();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.numTags = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.tags.push(MixPresentationTag.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MixPresentationTags {
    return {
      numTags: isSet(object.numTags) ? globalThis.Number(object.numTags) : 0,
      tags: globalThis.Array.isArray(object?.tags) ? object.tags.map((e: any) => MixPresentationTag.fromJSON(e)) : [],
    };
  },

  toJSON(message: MixPresentationTags): unknown {
    const obj: any = {};
    if (message.numTags !== undefined && message.numTags !== 0) {
      obj.numTags = Math.round(message.numTags);
    }
    if (message.tags?.length) {
      obj.tags = message.tags.map((e) => MixPresentationTag.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MixPresentationTags>, I>>(base?: I): MixPresentationTags {
    return MixPresentationTags.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MixPresentationTags>, I>>(object: I): MixPresentationTags {
    const message = createBaseMixPresentationTags();
    message.numTags = object.numTags ?? 0;
    message.tags = object.tags?.map((e) => MixPresentationTag.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMixPresentationObuMetadata(): MixPresentationObuMetadata {
  return {
    mixPresentationId: 0,
    countLabel: 0,
    languageLabels: [],
    annotationsLanguage: [],
    mixPresentationAnnotationsArray: [],
    localizedPresentationAnnotations: [],
    numSubMixes: 0,
    subMixes: [],
    includeMixPresentationTags: false,
    mixPresentationTags: undefined,
    obuHeader: undefined,
  };
}

export const MixPresentationObuMetadata: MessageFns<MixPresentationObuMetadata> = {
  encode(message: MixPresentationObuMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.mixPresentationId !== undefined && message.mixPresentationId !== 0) {
      writer.uint32(8).uint32(message.mixPresentationId);
    }
    if (message.countLabel !== undefined && message.countLabel !== 0) {
      writer.uint32(40).uint32(message.countLabel);
    }
    for (const v of message.languageLabels) {
      writer.uint32(50).string(v!);
    }
    for (const v of message.annotationsLanguage) {
      writer.uint32(74).string(v!);
    }
    for (const v of message.mixPresentationAnnotationsArray) {
      MixPresentationAnnotations.encode(v!, writer.uint32(58).fork()).join();
    }
    for (const v of message.localizedPresentationAnnotations) {
      writer.uint32(82).string(v!);
    }
    if (message.numSubMixes !== undefined && message.numSubMixes !== 0) {
      writer.uint32(24).uint32(message.numSubMixes);
    }
    for (const v of message.subMixes) {
      MixPresentationSubMix.encode(v!, writer.uint32(34).fork()).join();
    }
    if (message.includeMixPresentationTags !== undefined && message.includeMixPresentationTags !== false) {
      writer.uint32(88).bool(message.includeMixPresentationTags);
    }
    if (message.mixPresentationTags !== undefined) {
      MixPresentationTags.encode(message.mixPresentationTags, writer.uint32(98).fork()).join();
    }
    if (message.obuHeader !== undefined) {
      ObuHeaderMetadata.encode(message.obuHeader, writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MixPresentationObuMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMixPresentationObuMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.mixPresentationId = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.countLabel = reader.uint32();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.languageLabels.push(reader.string());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.annotationsLanguage.push(reader.string());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.mixPresentationAnnotationsArray.push(MixPresentationAnnotations.decode(reader, reader.uint32()));
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.localizedPresentationAnnotations.push(reader.string());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.numSubMixes = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.subMixes.push(MixPresentationSubMix.decode(reader, reader.uint32()));
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.includeMixPresentationTags = reader.bool();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.mixPresentationTags = MixPresentationTags.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.obuHeader = ObuHeaderMetadata.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MixPresentationObuMetadata {
    return {
      mixPresentationId: isSet(object.mixPresentationId) ? globalThis.Number(object.mixPresentationId) : 0,
      countLabel: isSet(object.countLabel) ? globalThis.Number(object.countLabel) : 0,
      languageLabels: globalThis.Array.isArray(object?.languageLabels)
        ? object.languageLabels.map((e: any) => globalThis.String(e))
        : [],
      annotationsLanguage: globalThis.Array.isArray(object?.annotationsLanguage)
        ? object.annotationsLanguage.map((e: any) => globalThis.String(e))
        : [],
      mixPresentationAnnotationsArray: globalThis.Array.isArray(object?.mixPresentationAnnotationsArray)
        ? object.mixPresentationAnnotationsArray.map((e: any) => MixPresentationAnnotations.fromJSON(e))
        : [],
      localizedPresentationAnnotations: globalThis.Array.isArray(object?.localizedPresentationAnnotations)
        ? object.localizedPresentationAnnotations.map((e: any) => globalThis.String(e))
        : [],
      numSubMixes: isSet(object.numSubMixes) ? globalThis.Number(object.numSubMixes) : 0,
      subMixes: globalThis.Array.isArray(object?.subMixes)
        ? object.subMixes.map((e: any) => MixPresentationSubMix.fromJSON(e))
        : [],
      includeMixPresentationTags: isSet(object.includeMixPresentationTags)
        ? globalThis.Boolean(object.includeMixPresentationTags)
        : false,
      mixPresentationTags: isSet(object.mixPresentationTags)
        ? MixPresentationTags.fromJSON(object.mixPresentationTags)
        : undefined,
      obuHeader: isSet(object.obuHeader) ? ObuHeaderMetadata.fromJSON(object.obuHeader) : undefined,
    };
  },

  toJSON(message: MixPresentationObuMetadata): unknown {
    const obj: any = {};
    if (message.mixPresentationId !== undefined && message.mixPresentationId !== 0) {
      obj.mixPresentationId = Math.round(message.mixPresentationId);
    }
    if (message.countLabel !== undefined && message.countLabel !== 0) {
      obj.countLabel = Math.round(message.countLabel);
    }
    if (message.languageLabels?.length) {
      obj.languageLabels = message.languageLabels;
    }
    if (message.annotationsLanguage?.length) {
      obj.annotationsLanguage = message.annotationsLanguage;
    }
    if (message.mixPresentationAnnotationsArray?.length) {
      obj.mixPresentationAnnotationsArray = message.mixPresentationAnnotationsArray.map((e) =>
        MixPresentationAnnotations.toJSON(e)
      );
    }
    if (message.localizedPresentationAnnotations?.length) {
      obj.localizedPresentationAnnotations = message.localizedPresentationAnnotations;
    }
    if (message.numSubMixes !== undefined && message.numSubMixes !== 0) {
      obj.numSubMixes = Math.round(message.numSubMixes);
    }
    if (message.subMixes?.length) {
      obj.subMixes = message.subMixes.map((e) => MixPresentationSubMix.toJSON(e));
    }
    if (message.includeMixPresentationTags !== undefined && message.includeMixPresentationTags !== false) {
      obj.includeMixPresentationTags = message.includeMixPresentationTags;
    }
    if (message.mixPresentationTags !== undefined) {
      obj.mixPresentationTags = MixPresentationTags.toJSON(message.mixPresentationTags);
    }
    if (message.obuHeader !== undefined) {
      obj.obuHeader = ObuHeaderMetadata.toJSON(message.obuHeader);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MixPresentationObuMetadata>, I>>(base?: I): MixPresentationObuMetadata {
    return MixPresentationObuMetadata.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MixPresentationObuMetadata>, I>>(object: I): MixPresentationObuMetadata {
    const message = createBaseMixPresentationObuMetadata();
    message.mixPresentationId = object.mixPresentationId ?? 0;
    message.countLabel = object.countLabel ?? 0;
    message.languageLabels = object.languageLabels?.map((e) => e) || [];
    message.annotationsLanguage = object.annotationsLanguage?.map((e) => e) || [];
    message.mixPresentationAnnotationsArray =
      object.mixPresentationAnnotationsArray?.map((e) => MixPresentationAnnotations.fromPartial(e)) || [];
    message.localizedPresentationAnnotations = object.localizedPresentationAnnotations?.map((e) => e) || [];
    message.numSubMixes = object.numSubMixes ?? 0;
    message.subMixes = object.subMixes?.map((e) => MixPresentationSubMix.fromPartial(e)) || [];
    message.includeMixPresentationTags = object.includeMixPresentationTags ?? false;
    message.mixPresentationTags = (object.mixPresentationTags !== undefined && object.mixPresentationTags !== null)
      ? MixPresentationTags.fromPartial(object.mixPresentationTags)
      : undefined;
    message.obuHeader = (object.obuHeader !== undefined && object.obuHeader !== null)
      ? ObuHeaderMetadata.fromPartial(object.obuHeader)
      : undefined;
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
