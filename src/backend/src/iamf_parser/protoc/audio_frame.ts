// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.0
//   protoc               v5.29.3
// source: audio_frame.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";

export const protobufPackage = "iamf_tools_cli_proto";

export enum ChannelLabel {
  CHANNEL_LABEL_INVALID = 0,
  /** CHANNEL_LABEL_MONO - Mono channels. */
  CHANNEL_LABEL_MONO = 2,
  /** CHANNEL_LABEL_L_2 - Stereo or binaural channels. */
  CHANNEL_LABEL_L_2 = 3,
  CHANNEL_LABEL_R_2 = 4,
  /** CHANNEL_LABEL_CENTRE - Centre channel common to several layouts (e.g. 3.1.2, 5.x.y, 7.x.y). */
  CHANNEL_LABEL_CENTRE = 6,
  /** CHANNEL_LABEL_LFE - LFE channel common to several layouts (e.g. 3.1.2, 5.1.y, 7.1.y, 9.1.6). */
  CHANNEL_LABEL_LFE = 7,
  /** CHANNEL_LABEL_L_3 - 3.1.2 surround channels. */
  CHANNEL_LABEL_L_3 = 8,
  CHANNEL_LABEL_R_3 = 9,
  CHANNEL_LABEL_LTF_3 = 10,
  CHANNEL_LABEL_RTF_3 = 11,
  /** CHANNEL_LABEL_L_5 - 5.x.y surround channels. */
  CHANNEL_LABEL_L_5 = 14,
  CHANNEL_LABEL_R_5 = 15,
  CHANNEL_LABEL_LS_5 = 16,
  CHANNEL_LABEL_RS_5 = 17,
  /** CHANNEL_LABEL_LTF_2 - Common channels between 5.1.2 and 7.1.2. */
  CHANNEL_LABEL_LTF_2 = 22,
  CHANNEL_LABEL_RTF_2 = 23,
  /** CHANNEL_LABEL_LTF_4 - Common channels between 5.1.4 and 7.1.4. */
  CHANNEL_LABEL_LTF_4 = 26,
  CHANNEL_LABEL_RTF_4 = 27,
  CHANNEL_LABEL_LTB_4 = 28,
  CHANNEL_LABEL_RTB_4 = 29,
  /** CHANNEL_LABEL_L_7 - 7.x.y surround channels. */
  CHANNEL_LABEL_L_7 = 32,
  CHANNEL_LABEL_R_7 = 33,
  CHANNEL_LABEL_LSS_7 = 34,
  CHANNEL_LABEL_RSS_7 = 35,
  CHANNEL_LABEL_LRS_7 = 36,
  CHANNEL_LABEL_RRS_7 = 37,
  /** CHANNEL_LABEL_FLC - 9.1.6 surround channels. */
  CHANNEL_LABEL_FLC = 42,
  CHANNEL_LABEL_FC = 43,
  CHANNEL_LABEL_FRC = 44,
  CHANNEL_LABEL_FL = 45,
  CHANNEL_LABEL_FR = 46,
  CHANNEL_LABEL_SI_L = 47,
  CHANNEL_LABEL_SI_R = 48,
  CHANNEL_LABEL_BL = 49,
  CHANNEL_LABEL_BR = 50,
  CHANNEL_LABEL_TP_FL = 51,
  CHANNEL_LABEL_TP_FR = 52,
  CHANNEL_LABEL_TP_SI_L = 53,
  CHANNEL_LABEL_TP_SI_R = 54,
  CHANNEL_LABEL_TP_BL = 55,
  CHANNEL_LABEL_TP_BR = 56,
  CHANNEL_LABEL_A_0 = 1000,
  CHANNEL_LABEL_A_1 = 1001,
  CHANNEL_LABEL_A_2 = 1002,
  CHANNEL_LABEL_A_3 = 1003,
  CHANNEL_LABEL_A_4 = 1004,
  CHANNEL_LABEL_A_5 = 1005,
  CHANNEL_LABEL_A_6 = 1006,
  CHANNEL_LABEL_A_7 = 1007,
  CHANNEL_LABEL_A_8 = 1008,
  CHANNEL_LABEL_A_9 = 1009,
  CHANNEL_LABEL_A_10 = 1010,
  CHANNEL_LABEL_A_11 = 1011,
  CHANNEL_LABEL_A_12 = 1012,
  CHANNEL_LABEL_A_13 = 1013,
  CHANNEL_LABEL_A_14 = 1014,
  CHANNEL_LABEL_A_15 = 1015,
  CHANNEL_LABEL_A_16 = 1016,
  CHANNEL_LABEL_A_17 = 1017,
  CHANNEL_LABEL_A_18 = 1018,
  CHANNEL_LABEL_A_19 = 1019,
  CHANNEL_LABEL_A_20 = 1020,
  CHANNEL_LABEL_A_21 = 1021,
  CHANNEL_LABEL_A_22 = 1022,
  CHANNEL_LABEL_A_23 = 1023,
  CHANNEL_LABEL_A_24 = 1024,
  UNRECOGNIZED = -1,
}

export function channelLabelFromJSON(object: any): ChannelLabel {
  switch (object) {
    case 0:
    case "CHANNEL_LABEL_INVALID":
      return ChannelLabel.CHANNEL_LABEL_INVALID;
    case 2:
    case "CHANNEL_LABEL_MONO":
      return ChannelLabel.CHANNEL_LABEL_MONO;
    case 3:
    case "CHANNEL_LABEL_L_2":
      return ChannelLabel.CHANNEL_LABEL_L_2;
    case 4:
    case "CHANNEL_LABEL_R_2":
      return ChannelLabel.CHANNEL_LABEL_R_2;
    case 6:
    case "CHANNEL_LABEL_CENTRE":
      return ChannelLabel.CHANNEL_LABEL_CENTRE;
    case 7:
    case "CHANNEL_LABEL_LFE":
      return ChannelLabel.CHANNEL_LABEL_LFE;
    case 8:
    case "CHANNEL_LABEL_L_3":
      return ChannelLabel.CHANNEL_LABEL_L_3;
    case 9:
    case "CHANNEL_LABEL_R_3":
      return ChannelLabel.CHANNEL_LABEL_R_3;
    case 10:
    case "CHANNEL_LABEL_LTF_3":
      return ChannelLabel.CHANNEL_LABEL_LTF_3;
    case 11:
    case "CHANNEL_LABEL_RTF_3":
      return ChannelLabel.CHANNEL_LABEL_RTF_3;
    case 14:
    case "CHANNEL_LABEL_L_5":
      return ChannelLabel.CHANNEL_LABEL_L_5;
    case 15:
    case "CHANNEL_LABEL_R_5":
      return ChannelLabel.CHANNEL_LABEL_R_5;
    case 16:
    case "CHANNEL_LABEL_LS_5":
      return ChannelLabel.CHANNEL_LABEL_LS_5;
    case 17:
    case "CHANNEL_LABEL_RS_5":
      return ChannelLabel.CHANNEL_LABEL_RS_5;
    case 22:
    case "CHANNEL_LABEL_LTF_2":
      return ChannelLabel.CHANNEL_LABEL_LTF_2;
    case 23:
    case "CHANNEL_LABEL_RTF_2":
      return ChannelLabel.CHANNEL_LABEL_RTF_2;
    case 26:
    case "CHANNEL_LABEL_LTF_4":
      return ChannelLabel.CHANNEL_LABEL_LTF_4;
    case 27:
    case "CHANNEL_LABEL_RTF_4":
      return ChannelLabel.CHANNEL_LABEL_RTF_4;
    case 28:
    case "CHANNEL_LABEL_LTB_4":
      return ChannelLabel.CHANNEL_LABEL_LTB_4;
    case 29:
    case "CHANNEL_LABEL_RTB_4":
      return ChannelLabel.CHANNEL_LABEL_RTB_4;
    case 32:
    case "CHANNEL_LABEL_L_7":
      return ChannelLabel.CHANNEL_LABEL_L_7;
    case 33:
    case "CHANNEL_LABEL_R_7":
      return ChannelLabel.CHANNEL_LABEL_R_7;
    case 34:
    case "CHANNEL_LABEL_LSS_7":
      return ChannelLabel.CHANNEL_LABEL_LSS_7;
    case 35:
    case "CHANNEL_LABEL_RSS_7":
      return ChannelLabel.CHANNEL_LABEL_RSS_7;
    case 36:
    case "CHANNEL_LABEL_LRS_7":
      return ChannelLabel.CHANNEL_LABEL_LRS_7;
    case 37:
    case "CHANNEL_LABEL_RRS_7":
      return ChannelLabel.CHANNEL_LABEL_RRS_7;
    case 42:
    case "CHANNEL_LABEL_FLC":
      return ChannelLabel.CHANNEL_LABEL_FLC;
    case 43:
    case "CHANNEL_LABEL_FC":
      return ChannelLabel.CHANNEL_LABEL_FC;
    case 44:
    case "CHANNEL_LABEL_FRC":
      return ChannelLabel.CHANNEL_LABEL_FRC;
    case 45:
    case "CHANNEL_LABEL_FL":
      return ChannelLabel.CHANNEL_LABEL_FL;
    case 46:
    case "CHANNEL_LABEL_FR":
      return ChannelLabel.CHANNEL_LABEL_FR;
    case 47:
    case "CHANNEL_LABEL_SI_L":
      return ChannelLabel.CHANNEL_LABEL_SI_L;
    case 48:
    case "CHANNEL_LABEL_SI_R":
      return ChannelLabel.CHANNEL_LABEL_SI_R;
    case 49:
    case "CHANNEL_LABEL_BL":
      return ChannelLabel.CHANNEL_LABEL_BL;
    case 50:
    case "CHANNEL_LABEL_BR":
      return ChannelLabel.CHANNEL_LABEL_BR;
    case 51:
    case "CHANNEL_LABEL_TP_FL":
      return ChannelLabel.CHANNEL_LABEL_TP_FL;
    case 52:
    case "CHANNEL_LABEL_TP_FR":
      return ChannelLabel.CHANNEL_LABEL_TP_FR;
    case 53:
    case "CHANNEL_LABEL_TP_SI_L":
      return ChannelLabel.CHANNEL_LABEL_TP_SI_L;
    case 54:
    case "CHANNEL_LABEL_TP_SI_R":
      return ChannelLabel.CHANNEL_LABEL_TP_SI_R;
    case 55:
    case "CHANNEL_LABEL_TP_BL":
      return ChannelLabel.CHANNEL_LABEL_TP_BL;
    case 56:
    case "CHANNEL_LABEL_TP_BR":
      return ChannelLabel.CHANNEL_LABEL_TP_BR;
    case 1000:
    case "CHANNEL_LABEL_A_0":
      return ChannelLabel.CHANNEL_LABEL_A_0;
    case 1001:
    case "CHANNEL_LABEL_A_1":
      return ChannelLabel.CHANNEL_LABEL_A_1;
    case 1002:
    case "CHANNEL_LABEL_A_2":
      return ChannelLabel.CHANNEL_LABEL_A_2;
    case 1003:
    case "CHANNEL_LABEL_A_3":
      return ChannelLabel.CHANNEL_LABEL_A_3;
    case 1004:
    case "CHANNEL_LABEL_A_4":
      return ChannelLabel.CHANNEL_LABEL_A_4;
    case 1005:
    case "CHANNEL_LABEL_A_5":
      return ChannelLabel.CHANNEL_LABEL_A_5;
    case 1006:
    case "CHANNEL_LABEL_A_6":
      return ChannelLabel.CHANNEL_LABEL_A_6;
    case 1007:
    case "CHANNEL_LABEL_A_7":
      return ChannelLabel.CHANNEL_LABEL_A_7;
    case 1008:
    case "CHANNEL_LABEL_A_8":
      return ChannelLabel.CHANNEL_LABEL_A_8;
    case 1009:
    case "CHANNEL_LABEL_A_9":
      return ChannelLabel.CHANNEL_LABEL_A_9;
    case 1010:
    case "CHANNEL_LABEL_A_10":
      return ChannelLabel.CHANNEL_LABEL_A_10;
    case 1011:
    case "CHANNEL_LABEL_A_11":
      return ChannelLabel.CHANNEL_LABEL_A_11;
    case 1012:
    case "CHANNEL_LABEL_A_12":
      return ChannelLabel.CHANNEL_LABEL_A_12;
    case 1013:
    case "CHANNEL_LABEL_A_13":
      return ChannelLabel.CHANNEL_LABEL_A_13;
    case 1014:
    case "CHANNEL_LABEL_A_14":
      return ChannelLabel.CHANNEL_LABEL_A_14;
    case 1015:
    case "CHANNEL_LABEL_A_15":
      return ChannelLabel.CHANNEL_LABEL_A_15;
    case 1016:
    case "CHANNEL_LABEL_A_16":
      return ChannelLabel.CHANNEL_LABEL_A_16;
    case 1017:
    case "CHANNEL_LABEL_A_17":
      return ChannelLabel.CHANNEL_LABEL_A_17;
    case 1018:
    case "CHANNEL_LABEL_A_18":
      return ChannelLabel.CHANNEL_LABEL_A_18;
    case 1019:
    case "CHANNEL_LABEL_A_19":
      return ChannelLabel.CHANNEL_LABEL_A_19;
    case 1020:
    case "CHANNEL_LABEL_A_20":
      return ChannelLabel.CHANNEL_LABEL_A_20;
    case 1021:
    case "CHANNEL_LABEL_A_21":
      return ChannelLabel.CHANNEL_LABEL_A_21;
    case 1022:
    case "CHANNEL_LABEL_A_22":
      return ChannelLabel.CHANNEL_LABEL_A_22;
    case 1023:
    case "CHANNEL_LABEL_A_23":
      return ChannelLabel.CHANNEL_LABEL_A_23;
    case 1024:
    case "CHANNEL_LABEL_A_24":
      return ChannelLabel.CHANNEL_LABEL_A_24;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ChannelLabel.UNRECOGNIZED;
  }
}

export function channelLabelToJSON(object: ChannelLabel): string {
  switch (object) {
    case ChannelLabel.CHANNEL_LABEL_INVALID:
      return "CHANNEL_LABEL_INVALID";
    case ChannelLabel.CHANNEL_LABEL_MONO:
      return "CHANNEL_LABEL_MONO";
    case ChannelLabel.CHANNEL_LABEL_L_2:
      return "CHANNEL_LABEL_L_2";
    case ChannelLabel.CHANNEL_LABEL_R_2:
      return "CHANNEL_LABEL_R_2";
    case ChannelLabel.CHANNEL_LABEL_CENTRE:
      return "CHANNEL_LABEL_CENTRE";
    case ChannelLabel.CHANNEL_LABEL_LFE:
      return "CHANNEL_LABEL_LFE";
    case ChannelLabel.CHANNEL_LABEL_L_3:
      return "CHANNEL_LABEL_L_3";
    case ChannelLabel.CHANNEL_LABEL_R_3:
      return "CHANNEL_LABEL_R_3";
    case ChannelLabel.CHANNEL_LABEL_LTF_3:
      return "CHANNEL_LABEL_LTF_3";
    case ChannelLabel.CHANNEL_LABEL_RTF_3:
      return "CHANNEL_LABEL_RTF_3";
    case ChannelLabel.CHANNEL_LABEL_L_5:
      return "CHANNEL_LABEL_L_5";
    case ChannelLabel.CHANNEL_LABEL_R_5:
      return "CHANNEL_LABEL_R_5";
    case ChannelLabel.CHANNEL_LABEL_LS_5:
      return "CHANNEL_LABEL_LS_5";
    case ChannelLabel.CHANNEL_LABEL_RS_5:
      return "CHANNEL_LABEL_RS_5";
    case ChannelLabel.CHANNEL_LABEL_LTF_2:
      return "CHANNEL_LABEL_LTF_2";
    case ChannelLabel.CHANNEL_LABEL_RTF_2:
      return "CHANNEL_LABEL_RTF_2";
    case ChannelLabel.CHANNEL_LABEL_LTF_4:
      return "CHANNEL_LABEL_LTF_4";
    case ChannelLabel.CHANNEL_LABEL_RTF_4:
      return "CHANNEL_LABEL_RTF_4";
    case ChannelLabel.CHANNEL_LABEL_LTB_4:
      return "CHANNEL_LABEL_LTB_4";
    case ChannelLabel.CHANNEL_LABEL_RTB_4:
      return "CHANNEL_LABEL_RTB_4";
    case ChannelLabel.CHANNEL_LABEL_L_7:
      return "CHANNEL_LABEL_L_7";
    case ChannelLabel.CHANNEL_LABEL_R_7:
      return "CHANNEL_LABEL_R_7";
    case ChannelLabel.CHANNEL_LABEL_LSS_7:
      return "CHANNEL_LABEL_LSS_7";
    case ChannelLabel.CHANNEL_LABEL_RSS_7:
      return "CHANNEL_LABEL_RSS_7";
    case ChannelLabel.CHANNEL_LABEL_LRS_7:
      return "CHANNEL_LABEL_LRS_7";
    case ChannelLabel.CHANNEL_LABEL_RRS_7:
      return "CHANNEL_LABEL_RRS_7";
    case ChannelLabel.CHANNEL_LABEL_FLC:
      return "CHANNEL_LABEL_FLC";
    case ChannelLabel.CHANNEL_LABEL_FC:
      return "CHANNEL_LABEL_FC";
    case ChannelLabel.CHANNEL_LABEL_FRC:
      return "CHANNEL_LABEL_FRC";
    case ChannelLabel.CHANNEL_LABEL_FL:
      return "CHANNEL_LABEL_FL";
    case ChannelLabel.CHANNEL_LABEL_FR:
      return "CHANNEL_LABEL_FR";
    case ChannelLabel.CHANNEL_LABEL_SI_L:
      return "CHANNEL_LABEL_SI_L";
    case ChannelLabel.CHANNEL_LABEL_SI_R:
      return "CHANNEL_LABEL_SI_R";
    case ChannelLabel.CHANNEL_LABEL_BL:
      return "CHANNEL_LABEL_BL";
    case ChannelLabel.CHANNEL_LABEL_BR:
      return "CHANNEL_LABEL_BR";
    case ChannelLabel.CHANNEL_LABEL_TP_FL:
      return "CHANNEL_LABEL_TP_FL";
    case ChannelLabel.CHANNEL_LABEL_TP_FR:
      return "CHANNEL_LABEL_TP_FR";
    case ChannelLabel.CHANNEL_LABEL_TP_SI_L:
      return "CHANNEL_LABEL_TP_SI_L";
    case ChannelLabel.CHANNEL_LABEL_TP_SI_R:
      return "CHANNEL_LABEL_TP_SI_R";
    case ChannelLabel.CHANNEL_LABEL_TP_BL:
      return "CHANNEL_LABEL_TP_BL";
    case ChannelLabel.CHANNEL_LABEL_TP_BR:
      return "CHANNEL_LABEL_TP_BR";
    case ChannelLabel.CHANNEL_LABEL_A_0:
      return "CHANNEL_LABEL_A_0";
    case ChannelLabel.CHANNEL_LABEL_A_1:
      return "CHANNEL_LABEL_A_1";
    case ChannelLabel.CHANNEL_LABEL_A_2:
      return "CHANNEL_LABEL_A_2";
    case ChannelLabel.CHANNEL_LABEL_A_3:
      return "CHANNEL_LABEL_A_3";
    case ChannelLabel.CHANNEL_LABEL_A_4:
      return "CHANNEL_LABEL_A_4";
    case ChannelLabel.CHANNEL_LABEL_A_5:
      return "CHANNEL_LABEL_A_5";
    case ChannelLabel.CHANNEL_LABEL_A_6:
      return "CHANNEL_LABEL_A_6";
    case ChannelLabel.CHANNEL_LABEL_A_7:
      return "CHANNEL_LABEL_A_7";
    case ChannelLabel.CHANNEL_LABEL_A_8:
      return "CHANNEL_LABEL_A_8";
    case ChannelLabel.CHANNEL_LABEL_A_9:
      return "CHANNEL_LABEL_A_9";
    case ChannelLabel.CHANNEL_LABEL_A_10:
      return "CHANNEL_LABEL_A_10";
    case ChannelLabel.CHANNEL_LABEL_A_11:
      return "CHANNEL_LABEL_A_11";
    case ChannelLabel.CHANNEL_LABEL_A_12:
      return "CHANNEL_LABEL_A_12";
    case ChannelLabel.CHANNEL_LABEL_A_13:
      return "CHANNEL_LABEL_A_13";
    case ChannelLabel.CHANNEL_LABEL_A_14:
      return "CHANNEL_LABEL_A_14";
    case ChannelLabel.CHANNEL_LABEL_A_15:
      return "CHANNEL_LABEL_A_15";
    case ChannelLabel.CHANNEL_LABEL_A_16:
      return "CHANNEL_LABEL_A_16";
    case ChannelLabel.CHANNEL_LABEL_A_17:
      return "CHANNEL_LABEL_A_17";
    case ChannelLabel.CHANNEL_LABEL_A_18:
      return "CHANNEL_LABEL_A_18";
    case ChannelLabel.CHANNEL_LABEL_A_19:
      return "CHANNEL_LABEL_A_19";
    case ChannelLabel.CHANNEL_LABEL_A_20:
      return "CHANNEL_LABEL_A_20";
    case ChannelLabel.CHANNEL_LABEL_A_21:
      return "CHANNEL_LABEL_A_21";
    case ChannelLabel.CHANNEL_LABEL_A_22:
      return "CHANNEL_LABEL_A_22";
    case ChannelLabel.CHANNEL_LABEL_A_23:
      return "CHANNEL_LABEL_A_23";
    case ChannelLabel.CHANNEL_LABEL_A_24:
      return "CHANNEL_LABEL_A_24";
    case ChannelLabel.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface ChannelMetadata {
  /**
   * Used to map the index of the channel in an ADM or WAV file. Ignored when
   * data comes from other sources.
   */
  channelId?:
    | number
    | undefined;
  /** The IAMF-based channel label. */
  channelLabel?: ChannelLabel | undefined;
}

export interface AudioFrameObuMetadata {
  wavFilename?:
    | string
    | undefined;
  /**
   * Controls whether the number of samples required to pad the final frame are
   * automatically added to the `samples_to_trim_at_end` value.
   *
   * When `true` `samples_to_trim_at_end` matches `num_samples_to_trim_at_end`
   * in the OBU header. If the actual value is too small to account for padding,
   * then encoding will fail. This is useful to closely represent the value in
   * the OBU (rarely needed).
   *
   * When `false` `num_samples_to_trim_at_end` will be incremented by the
   * amount of required padding and may not match the OBU header value. This is
   * useful to closely represent the trimming applied to the original audio
   * content (typically recommended).
   *
   * Typically the recommended settings are:
   *   - samples_to_trim_at_end_includes_padding: false
   *   - samples_to_trim_at_end: 0
   * These settings will automatically insert the correct padding to create a
   * valid final frame and avoid trimming the original audio content.
   */
  samplesToTrimAtEndIncludesPadding?: boolean | undefined;
  samplesToTrimAtEnd?:
    | number
    | undefined;
  /**
   * Controls whether the number of samples required by codec delay for the
   * initial first frames are automatically added to the
   * `samples_to_trim_at_start` value.
   *
   * When `true` `samples_to_trim_at_start` relates directly to
   * `samples_to_trim_at_start`s in the initial OBU header. If the actual
   * value is too small to account for codec delay, then encoding will fail.
   * This is useful to closely represent the values in the initial OBUs (rarely
   * needed).
   *
   * When `false` `samples_to_trim_at_start` will be incremented by the
   * amount of required for the codec delay and may not match the OBU header
   * value. This is useful to closely represent the trimming applied to the
   * original audio content (typically recommended).
   *
   * Typically the recommended settings are:
   *   - samples_to_trim_at_start_includes_codec_delay: false
   *   - samples_to_trim_at_start: 0
   * These settings will automatically insert the correct codec delay to create
   * a valid final frame and avoid trimming the original audio content.
   */
  samplesToTrimAtStartIncludesCodecDelay?: boolean | undefined;
  samplesToTrimAtStart?:
    | number
    | undefined;
  /**
   * ID of the audio element whose substreams will be provided/mixed
   * from the channels in this WAV file.
   */
  audioElementId?:
    | number
    | undefined;
  /**
   * Channels used in this WAV file, in the order as described in [ITU2051-3]
   * for loudspeaker layouts or ACN order for ambisonics. May be fewer than
   * the total number of channels in the WAV file if only a subset is to be
   * used.
   *
   * @deprecated
   */
  channelIds: number[];
  /**
   * Channel Labels, e.g. "L2", "Ls5". For ambisonics, use "A{ACN number}",
   * e.g. "A0", "A13". Must be of the same length as `channel_ids`.
   *
   * @deprecated
   */
  channelLabels: string[];
  /** Prefer `channel_metadata` over `channel_ids` and `channel_labels`. */
  channelMetadatas: ChannelMetadata[];
}

function createBaseChannelMetadata(): ChannelMetadata {
  return { channelId: 0, channelLabel: 0 };
}

export const ChannelMetadata: MessageFns<ChannelMetadata> = {
  encode(message: ChannelMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.channelId !== undefined && message.channelId !== 0) {
      writer.uint32(8).uint32(message.channelId);
    }
    if (message.channelLabel !== undefined && message.channelLabel !== 0) {
      writer.uint32(16).int32(message.channelLabel);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ChannelMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChannelMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.channelId = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.channelLabel = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChannelMetadata {
    return {
      channelId: isSet(object.channelId) ? globalThis.Number(object.channelId) : 0,
      channelLabel: isSet(object.channelLabel) ? channelLabelFromJSON(object.channelLabel) : 0,
    };
  },

  toJSON(message: ChannelMetadata): unknown {
    const obj: any = {};
    if (message.channelId !== undefined && message.channelId !== 0) {
      obj.channelId = Math.round(message.channelId);
    }
    if (message.channelLabel !== undefined && message.channelLabel !== 0) {
      obj.channelLabel = channelLabelToJSON(message.channelLabel);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ChannelMetadata>, I>>(base?: I): ChannelMetadata {
    return ChannelMetadata.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ChannelMetadata>, I>>(object: I): ChannelMetadata {
    const message = createBaseChannelMetadata();
    message.channelId = object.channelId ?? 0;
    message.channelLabel = object.channelLabel ?? 0;
    return message;
  },
};

function createBaseAudioFrameObuMetadata(): AudioFrameObuMetadata {
  return {
    wavFilename: "",
    samplesToTrimAtEndIncludesPadding: true,
    samplesToTrimAtEnd: 0,
    samplesToTrimAtStartIncludesCodecDelay: true,
    samplesToTrimAtStart: 0,
    audioElementId: 0,
    channelIds: [],
    channelLabels: [],
    channelMetadatas: [],
  };
}

export const AudioFrameObuMetadata: MessageFns<AudioFrameObuMetadata> = {
  encode(message: AudioFrameObuMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.wavFilename !== undefined && message.wavFilename !== "") {
      writer.uint32(10).string(message.wavFilename);
    }
    if (message.samplesToTrimAtEndIncludesPadding !== undefined && message.samplesToTrimAtEndIncludesPadding !== true) {
      writer.uint32(72).bool(message.samplesToTrimAtEndIncludesPadding);
    }
    if (message.samplesToTrimAtEnd !== undefined && message.samplesToTrimAtEnd !== 0) {
      writer.uint32(32).uint32(message.samplesToTrimAtEnd);
    }
    if (
      message.samplesToTrimAtStartIncludesCodecDelay !== undefined &&
      message.samplesToTrimAtStartIncludesCodecDelay !== true
    ) {
      writer.uint32(80).bool(message.samplesToTrimAtStartIncludesCodecDelay);
    }
    if (message.samplesToTrimAtStart !== undefined && message.samplesToTrimAtStart !== 0) {
      writer.uint32(40).uint32(message.samplesToTrimAtStart);
    }
    if (message.audioElementId !== undefined && message.audioElementId !== 0) {
      writer.uint32(48).uint32(message.audioElementId);
    }
    writer.uint32(58).fork();
    for (const v of message.channelIds) {
      writer.uint32(v);
    }
    writer.join();
    for (const v of message.channelLabels) {
      writer.uint32(66).string(v!);
    }
    for (const v of message.channelMetadatas) {
      ChannelMetadata.encode(v!, writer.uint32(90).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AudioFrameObuMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAudioFrameObuMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.wavFilename = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.samplesToTrimAtEndIncludesPadding = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.samplesToTrimAtEnd = reader.uint32();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.samplesToTrimAtStartIncludesCodecDelay = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.samplesToTrimAtStart = reader.uint32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.audioElementId = reader.uint32();
          continue;
        }
        case 7: {
          if (tag === 56) {
            message.channelIds.push(reader.uint32());

            continue;
          }

          if (tag === 58) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.channelIds.push(reader.uint32());
            }

            continue;
          }

          break;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.channelLabels.push(reader.string());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.channelMetadatas.push(ChannelMetadata.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AudioFrameObuMetadata {
    return {
      wavFilename: isSet(object.wavFilename) ? globalThis.String(object.wavFilename) : "",
      samplesToTrimAtEndIncludesPadding: isSet(object.samplesToTrimAtEndIncludesPadding)
        ? globalThis.Boolean(object.samplesToTrimAtEndIncludesPadding)
        : true,
      samplesToTrimAtEnd: isSet(object.samplesToTrimAtEnd) ? globalThis.Number(object.samplesToTrimAtEnd) : 0,
      samplesToTrimAtStartIncludesCodecDelay: isSet(object.samplesToTrimAtStartIncludesCodecDelay)
        ? globalThis.Boolean(object.samplesToTrimAtStartIncludesCodecDelay)
        : true,
      samplesToTrimAtStart: isSet(object.samplesToTrimAtStart) ? globalThis.Number(object.samplesToTrimAtStart) : 0,
      audioElementId: isSet(object.audioElementId) ? globalThis.Number(object.audioElementId) : 0,
      channelIds: globalThis.Array.isArray(object?.channelIds)
        ? object.channelIds.map((e: any) => globalThis.Number(e))
        : [],
      channelLabels: globalThis.Array.isArray(object?.channelLabels)
        ? object.channelLabels.map((e: any) => globalThis.String(e))
        : [],
      channelMetadatas: globalThis.Array.isArray(object?.channelMetadatas)
        ? object.channelMetadatas.map((e: any) => ChannelMetadata.fromJSON(e))
        : [],
    };
  },

  toJSON(message: AudioFrameObuMetadata): unknown {
    const obj: any = {};
    if (message.wavFilename !== undefined && message.wavFilename !== "") {
      obj.wavFilename = message.wavFilename;
    }
    if (message.samplesToTrimAtEndIncludesPadding !== undefined && message.samplesToTrimAtEndIncludesPadding !== true) {
      obj.samplesToTrimAtEndIncludesPadding = message.samplesToTrimAtEndIncludesPadding;
    }
    if (message.samplesToTrimAtEnd !== undefined && message.samplesToTrimAtEnd !== 0) {
      obj.samplesToTrimAtEnd = Math.round(message.samplesToTrimAtEnd);
    }
    if (
      message.samplesToTrimAtStartIncludesCodecDelay !== undefined &&
      message.samplesToTrimAtStartIncludesCodecDelay !== true
    ) {
      obj.samplesToTrimAtStartIncludesCodecDelay = message.samplesToTrimAtStartIncludesCodecDelay;
    }
    if (message.samplesToTrimAtStart !== undefined && message.samplesToTrimAtStart !== 0) {
      obj.samplesToTrimAtStart = Math.round(message.samplesToTrimAtStart);
    }
    if (message.audioElementId !== undefined && message.audioElementId !== 0) {
      obj.audioElementId = Math.round(message.audioElementId);
    }
    if (message.channelIds?.length) {
      obj.channelIds = message.channelIds.map((e) => Math.round(e));
    }
    if (message.channelLabels?.length) {
      obj.channelLabels = message.channelLabels;
    }
    if (message.channelMetadatas?.length) {
      obj.channelMetadatas = message.channelMetadatas.map((e) => ChannelMetadata.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AudioFrameObuMetadata>, I>>(base?: I): AudioFrameObuMetadata {
    return AudioFrameObuMetadata.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AudioFrameObuMetadata>, I>>(object: I): AudioFrameObuMetadata {
    const message = createBaseAudioFrameObuMetadata();
    message.wavFilename = object.wavFilename ?? "";
    message.samplesToTrimAtEndIncludesPadding = object.samplesToTrimAtEndIncludesPadding ?? true;
    message.samplesToTrimAtEnd = object.samplesToTrimAtEnd ?? 0;
    message.samplesToTrimAtStartIncludesCodecDelay = object.samplesToTrimAtStartIncludesCodecDelay ?? true;
    message.samplesToTrimAtStart = object.samplesToTrimAtStart ?? 0;
    message.audioElementId = object.audioElementId ?? 0;
    message.channelIds = object.channelIds?.map((e) => e) || [];
    message.channelLabels = object.channelLabels?.map((e) => e) || [];
    message.channelMetadatas = object.channelMetadatas?.map((e) => ChannelMetadata.fromPartial(e)) || [];
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
