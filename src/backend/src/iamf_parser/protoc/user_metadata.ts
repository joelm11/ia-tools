// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.0
//   protoc               v5.29.3
// source: user_metadata.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { ArbitraryObuMetadata } from "./arbitrary_obu";
import { AudioElementObuMetadata } from "./audio_element";
import { AudioFrameObuMetadata } from "./audio_frame";
import { CodecConfigObuMetadata } from "./codec_config";
import { EncoderControlMetadata } from "./encoder_control_metadata";
import { IASequenceHeaderObuMetadata } from "./ia_sequence_header";
import { MixPresentationObuMetadata } from "./mix_presentation";
import { ParameterBlockObuMetadata } from "./parameter_block";
import { TemporalDelimiterObuMetadata } from "./temporal_delimiter";
import { TestVectorMetadata } from "./test_vector_metadata";

export const protobufPackage = "iamf_tools_cli_proto";

export interface UserMetadata {
  /** Top-level metadata about the file. */
  testVectorMetadata?:
    | TestVectorMetadata
    | undefined;
  /** Knobs to control the encoder behavior. */
  encoderControlMetadata?:
    | EncoderControlMetadata
    | undefined;
  /** Descriptor OBUs. */
  iaSequenceHeaderMetadata: IASequenceHeaderObuMetadata[];
  codecConfigMetadata: CodecConfigObuMetadata[];
  audioElementMetadata: AudioElementObuMetadata[];
  mixPresentationMetadata: MixPresentationObuMetadata[];
  /** Temporal Unit OBUs. */
  audioFrameMetadata: AudioFrameObuMetadata[];
  parameterBlockMetadata: ParameterBlockObuMetadata[];
  temporalDelimiterMetadata?:
    | TemporalDelimiterObuMetadata
    | undefined;
  /**
   * A list of arbitrary OBUs to insert blindly into the stream. There is no
   * attempt to validate or process any side effects of adding the OBUs.
   */
  arbitraryObuMetadata: ArbitraryObuMetadata[];
}

function createBaseUserMetadata(): UserMetadata {
  return {
    testVectorMetadata: undefined,
    encoderControlMetadata: undefined,
    iaSequenceHeaderMetadata: [],
    codecConfigMetadata: [],
    audioElementMetadata: [],
    mixPresentationMetadata: [],
    audioFrameMetadata: [],
    parameterBlockMetadata: [],
    temporalDelimiterMetadata: undefined,
    arbitraryObuMetadata: [],
  };
}

export const UserMetadata: MessageFns<UserMetadata> = {
  encode(message: UserMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.testVectorMetadata !== undefined) {
      TestVectorMetadata.encode(message.testVectorMetadata, writer.uint32(74).fork()).join();
    }
    if (message.encoderControlMetadata !== undefined) {
      EncoderControlMetadata.encode(message.encoderControlMetadata, writer.uint32(98).fork()).join();
    }
    for (const v of message.iaSequenceHeaderMetadata) {
      IASequenceHeaderObuMetadata.encode(v!, writer.uint32(82).fork()).join();
    }
    for (const v of message.codecConfigMetadata) {
      CodecConfigObuMetadata.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.audioElementMetadata) {
      AudioElementObuMetadata.encode(v!, writer.uint32(26).fork()).join();
    }
    for (const v of message.mixPresentationMetadata) {
      MixPresentationObuMetadata.encode(v!, writer.uint32(34).fork()).join();
    }
    for (const v of message.audioFrameMetadata) {
      AudioFrameObuMetadata.encode(v!, writer.uint32(50).fork()).join();
    }
    for (const v of message.parameterBlockMetadata) {
      ParameterBlockObuMetadata.encode(v!, writer.uint32(58).fork()).join();
    }
    if (message.temporalDelimiterMetadata !== undefined) {
      TemporalDelimiterObuMetadata.encode(message.temporalDelimiterMetadata, writer.uint32(66).fork()).join();
    }
    for (const v of message.arbitraryObuMetadata) {
      ArbitraryObuMetadata.encode(v!, writer.uint32(90).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UserMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.testVectorMetadata = TestVectorMetadata.decode(reader, reader.uint32());
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.encoderControlMetadata = EncoderControlMetadata.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.iaSequenceHeaderMetadata.push(IASequenceHeaderObuMetadata.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.codecConfigMetadata.push(CodecConfigObuMetadata.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.audioElementMetadata.push(AudioElementObuMetadata.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.mixPresentationMetadata.push(MixPresentationObuMetadata.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.audioFrameMetadata.push(AudioFrameObuMetadata.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.parameterBlockMetadata.push(ParameterBlockObuMetadata.decode(reader, reader.uint32()));
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.temporalDelimiterMetadata = TemporalDelimiterObuMetadata.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.arbitraryObuMetadata.push(ArbitraryObuMetadata.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserMetadata {
    return {
      testVectorMetadata: isSet(object.testVectorMetadata)
        ? TestVectorMetadata.fromJSON(object.testVectorMetadata)
        : undefined,
      encoderControlMetadata: isSet(object.encoderControlMetadata)
        ? EncoderControlMetadata.fromJSON(object.encoderControlMetadata)
        : undefined,
      iaSequenceHeaderMetadata: globalThis.Array.isArray(object?.iaSequenceHeaderMetadata)
        ? object.iaSequenceHeaderMetadata.map((e: any) => IASequenceHeaderObuMetadata.fromJSON(e))
        : [],
      codecConfigMetadata: globalThis.Array.isArray(object?.codecConfigMetadata)
        ? object.codecConfigMetadata.map((e: any) => CodecConfigObuMetadata.fromJSON(e))
        : [],
      audioElementMetadata: globalThis.Array.isArray(object?.audioElementMetadata)
        ? object.audioElementMetadata.map((e: any) => AudioElementObuMetadata.fromJSON(e))
        : [],
      mixPresentationMetadata: globalThis.Array.isArray(object?.mixPresentationMetadata)
        ? object.mixPresentationMetadata.map((e: any) => MixPresentationObuMetadata.fromJSON(e))
        : [],
      audioFrameMetadata: globalThis.Array.isArray(object?.audioFrameMetadata)
        ? object.audioFrameMetadata.map((e: any) => AudioFrameObuMetadata.fromJSON(e))
        : [],
      parameterBlockMetadata: globalThis.Array.isArray(object?.parameterBlockMetadata)
        ? object.parameterBlockMetadata.map((e: any) => ParameterBlockObuMetadata.fromJSON(e))
        : [],
      temporalDelimiterMetadata: isSet(object.temporalDelimiterMetadata)
        ? TemporalDelimiterObuMetadata.fromJSON(object.temporalDelimiterMetadata)
        : undefined,
      arbitraryObuMetadata: globalThis.Array.isArray(object?.arbitraryObuMetadata)
        ? object.arbitraryObuMetadata.map((e: any) => ArbitraryObuMetadata.fromJSON(e))
        : [],
    };
  },

  toJSON(message: UserMetadata): unknown {
    const obj: any = {};
    if (message.testVectorMetadata !== undefined) {
      obj.testVectorMetadata = TestVectorMetadata.toJSON(message.testVectorMetadata);
    }
    if (message.encoderControlMetadata !== undefined) {
      obj.encoderControlMetadata = EncoderControlMetadata.toJSON(message.encoderControlMetadata);
    }
    if (message.iaSequenceHeaderMetadata?.length) {
      obj.iaSequenceHeaderMetadata = message.iaSequenceHeaderMetadata.map((e) => IASequenceHeaderObuMetadata.toJSON(e));
    }
    if (message.codecConfigMetadata?.length) {
      obj.codecConfigMetadata = message.codecConfigMetadata.map((e) => CodecConfigObuMetadata.toJSON(e));
    }
    if (message.audioElementMetadata?.length) {
      obj.audioElementMetadata = message.audioElementMetadata.map((e) => AudioElementObuMetadata.toJSON(e));
    }
    if (message.mixPresentationMetadata?.length) {
      obj.mixPresentationMetadata = message.mixPresentationMetadata.map((e) => MixPresentationObuMetadata.toJSON(e));
    }
    if (message.audioFrameMetadata?.length) {
      obj.audioFrameMetadata = message.audioFrameMetadata.map((e) => AudioFrameObuMetadata.toJSON(e));
    }
    if (message.parameterBlockMetadata?.length) {
      obj.parameterBlockMetadata = message.parameterBlockMetadata.map((e) => ParameterBlockObuMetadata.toJSON(e));
    }
    if (message.temporalDelimiterMetadata !== undefined) {
      obj.temporalDelimiterMetadata = TemporalDelimiterObuMetadata.toJSON(message.temporalDelimiterMetadata);
    }
    if (message.arbitraryObuMetadata?.length) {
      obj.arbitraryObuMetadata = message.arbitraryObuMetadata.map((e) => ArbitraryObuMetadata.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UserMetadata>, I>>(base?: I): UserMetadata {
    return UserMetadata.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UserMetadata>, I>>(object: I): UserMetadata {
    const message = createBaseUserMetadata();
    message.testVectorMetadata = (object.testVectorMetadata !== undefined && object.testVectorMetadata !== null)
      ? TestVectorMetadata.fromPartial(object.testVectorMetadata)
      : undefined;
    message.encoderControlMetadata =
      (object.encoderControlMetadata !== undefined && object.encoderControlMetadata !== null)
        ? EncoderControlMetadata.fromPartial(object.encoderControlMetadata)
        : undefined;
    message.iaSequenceHeaderMetadata =
      object.iaSequenceHeaderMetadata?.map((e) => IASequenceHeaderObuMetadata.fromPartial(e)) || [];
    message.codecConfigMetadata = object.codecConfigMetadata?.map((e) => CodecConfigObuMetadata.fromPartial(e)) || [];
    message.audioElementMetadata = object.audioElementMetadata?.map((e) => AudioElementObuMetadata.fromPartial(e)) ||
      [];
    message.mixPresentationMetadata =
      object.mixPresentationMetadata?.map((e) => MixPresentationObuMetadata.fromPartial(e)) || [];
    message.audioFrameMetadata = object.audioFrameMetadata?.map((e) => AudioFrameObuMetadata.fromPartial(e)) || [];
    message.parameterBlockMetadata =
      object.parameterBlockMetadata?.map((e) => ParameterBlockObuMetadata.fromPartial(e)) || [];
    message.temporalDelimiterMetadata =
      (object.temporalDelimiterMetadata !== undefined && object.temporalDelimiterMetadata !== null)
        ? TemporalDelimiterObuMetadata.fromPartial(object.temporalDelimiterMetadata)
        : undefined;
    message.arbitraryObuMetadata = object.arbitraryObuMetadata?.map((e) => ArbitraryObuMetadata.fromPartial(e)) || [];
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
